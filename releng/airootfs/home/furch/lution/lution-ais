# !/bin/bash
#
# Lution-AIS installer (version 0.3 - September 2014)
#
# Written by Carl Duff for Evo/Lution Linux
#
# Some code has been used or adapted from the Arch Installation Script (AIS)
# and Arch Ultimate Installer (AUI) written by helmuthdu, the Antergos 
# CLI installer written by Alex Filgueira, and the Manjaro 0.8 installer
# Written by Philip Muller.
#
# This program is free software, provided under the GNU General Public License
# as published by the Free Software Foundation. So feel free to copy, distribute,
# or modify it as you wish.
#



######################################################################
##																	##
##                   Installer Variables							##
##																	##
######################################################################

# Create a temporary file to store menu selections
ANSWER="/tmp/.lution"

# Save retyping
VERSION="Lution-AIS 0.3"

# Installation
  KDE_INSTALLED=0      	# Has KDE been installed? Used for display manager option
  GNOME_INSTALLED=0    	# Has Gnome been installed? Used for display manager option
  LXDE_INSTALLED=0     	# Has LXDE been installed? Used for display manager option
  DM_INSTALLED=0       	# Has a display manager been installed?
  COMMON_INSTALLED=0   	# Has the common-packages option been taken?
  NM_INSTALLED=0       	# Has a network connection manager been installed and enabled?
  KEYMAP="us"          	# Virtual console keymap. Default is "us"
  XKBMAP="us"      	    # X11 keyboard layout. Default is "us"
  ZONE=""               # For time
  SUBZONE=""            # For time
  LOCALE="en_US.UTF-8"  # System locale. Default is "en_US.UTF-8"
  LTS=0                	# Has the LTS Kernel been installed?
  GRAPHIC_CARD=`hwinfo --gfxcard|grep 'Model:[[:space:]]'`  # Auto-detect popular graphics cards
  GC_DETECTED=""        # Name of Graphics Card Detected
  SHOW_ONCE=0           # Show de_wm information only once
  TUITION_MODE=0        # Extra information for beginners
  
# Architecture
  ARCHI=`uname -m`     	# Display whether 32 or 64 bit system
  UEFI=0               	# Is the system UEFI?
  SYSTEM="Unknown"     	# Display whether system is BIOS or UEFI. Default is "unknown"
  ROOT_PART=""          # ROOT partition
  UEFI_PART=""          # UEFI partition
  INST_DEV=""           # Device where system has been installed

# Installation
  MOUNTPOINT="/mnt"


######################################################################
##																	##
##                        Core Functions							##
##																	##
######################################################################


# Check user is root, and that there is an active internet connection
# Seperated the checks into seperate "if" statements for readability.
check_evo_requirements() {
	
  dialog --backtitle "$VERSION" --title " Checking Evo Requirements " --infobox "\nChecking installer has been run as root and that there is an active internet connection. Please wait..." 7 40
  sleep 2
  
  if [[ `whoami` != "root" ]]; then
     dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Root Failure " --infobox "\nThe installer must be run as root. Exiting.\n" 6 30
     sleep 2
     exit 1
  fi
  
  if [[ ! ` ping -c 1 google.com ` ]]; then
     dialog --backtitle "$VERSION" --title " Connection Failure " --infobox "\nInternet connection test failed. Exiting.\n" 6 30
     sleep 2
     exit 1
  else
     dialog --backtitle "$VERSION" --title " Requirements Met " --infobox "\nAll checks passed! \n" 5 30
     sleep 2   
     clear
     pacman -Syy
  fi

}

# Modified from the AIS check_boot_system function to identify if
# system is made by Apple, and whether BIOS or UEFI is used.
id_system() {
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
      modprobe -r -q efivars || true  # if MAC
    else
      modprobe -q efivarfs            # all others
    fi
    
    if [[ -d "/sys/firmware/efi/" ]]; then
      ## Mount efivarfs if it is not already mounted
      if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars
      fi
      UEFI=1
      SYSTEM="UEFI System Detected"
    else
      UEFI=0
      SYSTEM="BIOS System Detected"
    fi
}

# Taken from AIS. An excellent bit of code!
arch_chroot() {
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}"
}  

######################################################################
##																	##
##                 Configuration Functions							##
##																	##
######################################################################


# Adapted from AIS. Added option to allow users to edit the mirrorlist.
configure_mirrorlist() {

# Generate a mirrorlist based on the country chosen.	
mirror_by_country() {

 COUNTRY_LIST=""
 countries_list=("AU_Australia AT_Austria BY_Belarus BE_Belgium BR_Brazil BG_Bulgaria CA_Canada CL_Chile CN_China CO_Colombia CZ_Czech_Republic DK_Denmark EE_Estonia FI_Finland FR_France DE_Germany GR_Greece HU_Hungary IN_India IE_Ireland IL_Israel IT_Italy JP_Japan KZ_Kazakhstan KR_Korea LV_Latvia LU_Luxembourg MK_Macedonia NL_Netherlands NC_New_Caledonia NZ_New_Zealand NO_Norway PL_Poland PT_Portugal RO_Romania RU_Russia RS_Serbia SG_Singapore SK_Slovakia ZA_South_Africa ES_Spain LK_Sri_Lanka SE_Sweden CH_Switzerland TW_Taiwan TR_Turkey UA_Ukraine GB_United_Kingdom US_United_States UZ_Uzbekistan VN_Vietnam")

 for i in ${countries_list}; do
     COUNTRY_LIST="${COUNTRY_LIST} ${i} -"
 done
	
 dialog --backtitle "$VERSION" --title " Select Country " --menu "\nA list of mirrors by the selected country will be generated.\n\nOnce reviewed, you can choose to use it or not." 20 45 16 ${COUNTRY_LIST} 2>${ANSWER} || prep_menu
 COUNTRY_CODE=$(cat ${ANSWER} |sed 's/_.*//')

 URL="https://www.archlinux.org/mirrorlist/?country=${COUNTRY_CODE}&use_mirror_status=on"
 MIRROR_TEMP=$(mktemp --suffix=-mirrorlist)

 # Get latest mirror list and save to tmpfile
 dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Generating Mirrorlist " --infobox "\nGenerating a mirrorlist. Please wait... " 7 40
  
 curl -so ${MIRROR_TEMP} ${URL}
 sed -i 's/^#Server/Server/g' ${MIRROR_TEMP}
 leafpad ${MIRROR_TEMP}

 dialog --yesno $"Use generated mirrorlist for installer?" 0 0 \
 && mv -i -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig \
 && mv -i -f ${MIRROR_TEMP} /etc/pacman.d/mirrorlist \
 && chmod +r /etc/pacman.d/mirrorlist \
 && dialog --msgbox "\nDone! Original Mirrorlist has been saved as:\n\n/etc/pacman.d/mirrorlist.orig" 10 40 || prep_menu
}

dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Mirrorlist " \
    --menu $"\nThe mirrorlist contains server addresses used by pacman to install packages. They are accessed by pacman in the order listed.\n\n" 13 45 2 \
	"1" $"Generate list by Country" \
	"2" $"Manually edit mirrorlist" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") mirror_by_country
             ;;
        "2") gksu leafpad /etc/pacman.d/mirrorlist
             ;;
          *) prep_menu
             ;;
    esac  	

}

# Simplified from the Arch --> Cinnarch/Antergos --> Manjaro installer code.
set_keymap() { 
	
	KEYMAPS=""
    for i in $(find /usr/share/kbd/keymaps -follow -name "*.gz" | sed 's|^.*/||g' | sed 's/.map.*//' | sort); do
        KEYMAPS="${KEYMAPS} ${i} -"
    done
    
    dialog --backtitle "$VERSION" --title " Select Keymap " \
    --menu "\nUse the [pg up] and [pg dwn] keys for navigation, or press the first letter of the keymap if known." 20 40 16 ${KEYMAPS} 2>${ANSWER} || config_base_menu
    KEYMAP=$(cat ${ANSWER})
    echo "KEYMAP=$KEYMAP" > ${MOUNTPOINT}/etc/vconsole.conf
  }

# Set keymap for X11
 set_xkbmap() {
	 
	XKBMAP_LIST=""
	keymaps_xkb=("af_Afghani al_Albanian am_Armenian ara_Arabic at_German-Austria az_Azerbaijani ba_Bosnian bd_Bangla be_Belgian bg_Bulgarian br_Portuguese-Brazil bt_Dzongkha bw_Tswana by_Belarusian ca_French-Canada cd_French-DR-Congo ch_German-Switzerland cm_English-Cameroon cn_Chinese cz_Czech de_German dk_Danishee_Estonian epo_Esperanto es_Spanish et_Amharic fo_Faroese fi_Finnish fr_French gb_English-UK ge_Georgian gh_English-Ghana gn_French-Guinea gr_Greek hr_Croatian hu_Hungarian ie_Irish il_Hebrew iq_Iraqi ir_Persian is_Icelandic it_Italian jp_Japanese ke_Swahili-Kenya kg_Kyrgyz kh_Khmer-Cambodia kr_Korean kz_Kazakh la_Lao latam_Spanish-Lat-American lk_Sinhala-phonetic lt_Lithuanian lv_Latvian ma_Arabic-Morocco mao_Maori md_Moldavian me_Montenegrin mk_Macedonian ml_Bambara mm_Burmese mn_Mongolian mt_Maltese mv_Dhivehi ng_English-Nigeria nl_Dutch no_Norwegian np_Nepali ph_Filipino pk_Urdu-Pakistan pl_Polish pt_Portuguese ro_Romanian rs_Serbian ru_Russian se_Swedish si_Slovenian sk_Slovak sn_Wolof sy_Arabic-Syria th_Thai tj_Tajik tm_Turkmen tr_Turkish tw_Taiwanese tz_Swahili-Tanzania ua_Ukrainian us_English-US uz_Uzbek vn_Vietnamese za_English-S-Africa")
    
	for i in ${keymaps_xkb}; do
        XKBMAP_LIST="${XKBMAP_LIST} ${i} -"
    done
	
    dialog --backtitle "$VERSION" --title " Select xkbmap " --menu "Select Keyboard Layout" 20 45 16 ${XKBMAP_LIST} 2>${ANSWER} || prep_menu
    XKBMAP=$(cat ${ANSWER} |sed 's/_.*//')
    setxkbmap $XKBMAP
 
}

# locale array generation code taken from the Manjaro 0.8 installer
set_locale() {
	
  LOCALES=""	
  for i in $(cat /etc/locale.gen | grep -v "#  " | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8); do
      LOCALES="${LOCALES} ${i} -"
  done

  dialog --backtitle "$VERSION" --title " Select locale " --menu "Select A Locale" 22 30 16 ${LOCALES} 2>${ANSWER} || config_base_menu 
  LOCALE=$(cat ${ANSWER})
  
  echo 'LANG="'$LOCALE'"' > ${MOUNTPOINT}/etc/locale.conf  
  arch_chroot "sed -i '/'${LOCALE}'/s/^#//' /etc/locale.gen"
  arch_chroot "locale-gen"
}

# Zone and sub-zone array generation code taken from the Manjaro 0.8 Installer
set_timezone() {

    ZONE=""
    for i in $(grep '^[A-Z]' /usr/share/zoneinfo/zone.tab | cut -f 3 | sed -e 's#/.*##g'| sort -u); do
      ZONE="$ZONE ${i} -"
    done
    
     dialog --backtitle "$VERSION" --title " Select Time Zone " --menu "\n." 20 40 12 ${ZONE} 2>${ANSWER} || config_base_menu
     ZONE=$(cat ${ANSWER}) 
    
     SUBZONE=""
     for i in $(grep '^[A-Z]' /usr/share/zoneinfo/zone.tab | grep $ZONE/ | cut -f 3 | sed -e "s#$ZONE/##g"| sort -u); do
        SUBZONE="$SUBZONE ${i} -"
     done
         
     dialog --backtitle "$VERSION" --title " Select Time Sub-Zone " --menu "\n." 20 40 12 ${SUBZONE} 2>${ANSWER} || config_base_menu
     SUBZONE=$(cat ${ANSWER}) 
    
     dialog --yesno $"Set Time Zone as ${ZONE}/${SUBZONE} ?" 0 0 && arch_chroot "ln -s /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime" || config_base_menu
    
}

set_hw_clock() {
	
   dialog --backtitle "$VERSION" --title " Set Hardware Clock " \
    --menu $"" 9 50 3 \
 	"1" $"UTC" \
	"2" $"Local Time" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") arch_chroot "hwclock --systohc --utc" 
             ;;
        "2") arch_chroot "hwclock --systohc --localtime"
             ;;
          *) config_base_menu
             ;;
     esac	
}

# Adapted from AIS. As with some other functions, decided that keeping the numbering for options
# was worth repeating portions of code.
generate_fstab() {

    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Generate FSTAB " \
    --menu "\nThe FSTAB file (File System TABle) sets what storage devices and partitions are to be mounted, and how they are to be used.\n\nUUID/PARTUUID (Universally Unique IDentifier) is recommended.\n\nIf no labels were set for the partitions earlier, device names will be used for the label option." 19 60 3 \
	"1" $"Dev (partition code)" \
	"2" $"Label (user defined)" \
	"3" $"UUID/PARTUUID (unique code)" 2>${ANSWER}

    case $(cat ${ANSWER}) in
        "1") genfstab -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab
             ;;
        "2") genfstab -L -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab
             ;;
        "3") if [[ $UEFI -eq 1 ]]; then
                genfstab -t PARTUUID -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab
             else 
                genfstab -U -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab
             fi
             ;;
          *) config_base_menu
             ;;
    esac

    gksu leafpad ${MOUNTPOINT}/etc/fstab
}

# Adapted from AIS.
set_hostname() {

   dialog --backtitle "$VERSION" --title " Configure Host Name " --inputbox "\nThe host name is used to identify the system on a network.\n\nIt is restricted to alphanumeric characters, can contain a hyphen (-) - but not at the start or end - and must be no longer than 63 characters.\n" 12 65 "evo" 2>${ANSWER} || config_base_menu
   HOST_NAME=$(cat ${ANSWER})

   echo "$HOST_NAME" > ${MOUNTPOINT}/etc/hostname
   arch_chroot "sed -i '/127.0.0.1/s/$/ '${HOST_NAME}'/' /etc/hosts"
   arch_chroot "sed -i '/::1/s/$/ '${HOST_NAME}'/' /etc/hosts"
}

# Adapted and simplified from the Manjaro 0.8 and Antergos 2.0 installers
set_root_password() {


    dialog --title " Set Root Password " --clear --insecure --passwordbox "\nEnter Root password\n\n" 10 55 2> ${ANSWER}
    PASSWD=$(cat ${ANSWER})
    
    dialog --title " Set Root Password " --clear --insecure --passwordbox "\nRe-enter Root password\n\n" 10 55 2> ${ANSWER}
    PASSWD2=$(cat ${ANSWER})
    
    if [[ $PASSWD == $PASSWD2 ]]; then 
       echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
       arch_chroot "passwd root" < /tmp/.passwd
       rm /tmp/.passwd
    else
       dialog --backtitle "$VERSION" --title " Root Password Error " --msgbox $"\nThe Root passwords entered do not match. Please try again.\n" 8 35
       set_root_password
    fi

}

# Adapted and simplified from the Antergos 2.0 installer
create_new_user() {

        dialog --backtitle "$VERSION" --title " Create New User " --inputbox "\nEnter the user name.\n\nIt is recommended to use all lower-case letters.\n" 11 55 "" 2>${ANSWER} || config_base_menu
        USER=$(cat ${ANSWER})
        
        if [[ $USER == "" ]]; then
           dialog --backtitle "$VERSION" --title " User Name Error " --msgbox $"\nNo user name was entered. Please try again.\n" 8 35
           create_new_user
        else
           dialog --title " Set User Password " --clear --insecure --passwordbox "\nEnter password for $USER\n\n" 10 55 2> ${ANSWER}
           PASSWD=$(cat ${ANSWER}) 
    
           dialog --title " Set User Password " --clear --insecure --passwordbox "\nRe-enter password for $USER\n\n" 10 55 2> ${ANSWER}
           PASSWD2=$(cat ${ANSWER}) 
    
           if [[ $PASSWD == $PASSWD2 ]]; then         
              dialog --backtitle "$VERSION" --title " Setting User " --infobox "\nCreating User and setting groups...\n" 6 40
              sleep 2
              arch_chroot "useradd ${USER} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/bash"
              echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
              arch_chroot "passwd ${USER}" < /tmp/.passwd
              rm /tmp/.passwd
             # arch_chroot "cp /etc/skel/.bashrc /home/${USER}"
             # arch_chroot "chown -R ${USER}:users /home/${USER}"
              arch_chroot "sed -i '/%wheel ALL=(ALL) ALL/s/^#//' /etc/sudoers"
           else
              dialog --backtitle "$VERSION" --title " User Password Error " --msgbox $"\nThe User passwords entered do not match. Please try again.\n" 8 35
              create_new_user
           fi
         fi
}

run_mkinitcpio() {
	
  clear
  if [[ $LTS -eq 1 ]]; then
     arch_chroot "mkinitcpio -p linux-lts"
  else
     arch_chroot "mkinitcpio -p linux"
  fi

}

######################################################################
##																	##
##            System and Partitioning Functions						##
##																	##
######################################################################



# Unmount partitions (AIS)
umount_partitions(){
  mounted_partitions=(`lsblk | grep ${MOUNTPOINT} | awk '{print $7}' | sort -r`)
  swapoff -a
  for i in ${mounted_partitions[@]}; do
    umount $i
  done
}

# Adapted from AIS
confirm_mount() {
    if mount | grep $1; then
      dialog --backtitle "$VERSION" --title " Mount Status " --infobox "\nMount Successful!\n" 5 30
      sleep 2
      PARTITIONS="$(echo $PARTITIONS | sed s/${PARTITION}$' -'//)"
      NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    else
      dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Mount Status " --infobox "Mount Failed!" 5 30
      sleep 2
      config_base_menu
    fi
}

# Adapted from AIS. However, this does not assume that the formatted device is the Root
# installation device; more than one device may be formatted. This is now set in the
# mount_partitions function, when the Root is chosen.
select_device() {
	
    DEVICE=""
    devices_list=(`lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd'`);
    
    for i in ${devices_list[@]}; do
        DEVICE="${DEVICE} ${i} -"
    done
    
    dialog --backtitle "$VERSION" --title " Select Device " --menu "\n." 10 40 3 ${DEVICE} 2>${ANSWER} || prep_menu
    DEVICE=$(cat ${ANSWER}) 
  }

# Adapted from AIS. Integrated Gparted, and dropped most of the other partitioning tools.
create_partitions(){
# add more paritioning tools
    dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Partitioning Tool " \
    --menu $"\nGParted is a recommended user-friendly graphical tool that supports both BIOS and UEFI systems." 13 55 3 \
 	"1" $"GParted (GUI - BIOS & UEFI)" \
	"2" $"CFDisk  (CLI - BIOS)" \
	"3" $"GDisk   (CLI - UEFI/GPT)" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") gksu gparted ${DEVICE} 
             ;;
        "2") cfdisk ${DEVICE}
             ;;
        "3") gdisk ${DEVICE}
             ;;
          *) prep_menu
             ;;
    esac  	
}	

# find all available partitions and generate a list of them
# This also includes partitions on different devices.
find_partitions() {
	
	
	PARTITIONS=""
    partition_list=(`lsblk | grep 'part\|lvm' | awk '{print substr($1,3)}'`)
	
    for i in ${partition_list[@]}; do
        PARTITIONS="${PARTITIONS} ${i} -"
    done
    
    echo $PARTITIONS
    NUMBER_PARTITIONS=${#partition_list[@]}
    
    # Deal with incorrect partitioning
    if [[ $NUMBER_PARTITIONS < 2 ]] && [[ $UEFI -eq 1 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " UEFI Partitioning Error " --msgbox $"\nUEFI systems require a minimum of two partitions for installation (ROOT and UEFI).\n\nPlease configure your partitions." 0 0
        create_partitions
    fi
    
    if [[ $NUMBER_PARTITIONS -eq 0 ]] && [[ $UEFI -eq 0 ]]; then
        dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " BIOS Partitioning Error " --msgbox $"\nBIOS systems require a minmum of one partition for installation (ROOT).\n\nPlease configure your partitions." 0 0	
        create_partitions
    fi
}

# Not all filesystems available are viable, so set static list.
select_filesystem(){
	
	dialog --backtitle "$VERSION" --title " Choose Filesystem " \
    --menu $"Ext4 is recommended for beginners." 19 30 11 \
 	"1" $"SKIP" \
	"2" $"btrfs" \
	"3" $"ext2" \
 	"4" $"ext3" \
	"5" $"ext4" \
	"6" $"jfs" \
 	"7" $"nilfs2" \
	"8" $"ntfs" \
	"9" $"reiserfs" \
 	"10" $"vfat" \
	"11" $"xfs" 2>${ANSWER}		

    case $(cat ${ANSWER}) in
        "1") FILESYSTEM="skip"
             ;;
        "2") FILESYSTEM="mkfs.btrfs -f"
             ;;
        "3") FILESYSTEM="mkfs.ext2 -F"
             ;;
        "4") FILESYSTEM="mkfs.ext3 -F"
             ;;            
        "5") FILESYSTEM="mkfs.ext4 -F"
             ;;
        "6") FILESYSTEM="mkfs.jfs -q"
             ;;
        "7") FILESYSTEM="mkfs.nilfs2 -f"
             ;;  
        "8") FILESYSTEM="mkfs.ntfs -q"
             ;;  
        "9") FILESYSTEM="mkfs.reiserfs -f -f"
             ;;  
       "10") FILESYSTEM="mkfs.vfat -F32"
             ;;  
       "11") FILESYSTEM="mkfs.xfs -f"
             ;;      
          *) prep_menu
             ;;
    esac 	

  }
  
mount_partitions() {
	
	# Ensure all partitions are unmounted (e.g. could still be mounted from the partitioning tool)
    # Then list available partitions
	find_partitions
	
	# Identify and mount root
	dialog --backtitle "$VERSION" --title " Select ROOT Partition " --menu "\n." 12 40 4 ${PARTITIONS} 2>${ANSWER} || config_base_menu
	PARTITION=$(cat ${ANSWER})
    ROOT_PART=${PARTITION}
	INST_DEV=$"/dev/"$(cat ${ANSWER} | sed 's/[0-9]*//g')
	
	select_filesystem
	if [[ $FILESYSTEM != "skip" ]]; then	
	   ${FILESYSTEM} $"/dev/"${PARTITION} >/dev/null 2>&1
	fi
	
	mkdir -p ${MOUNTPOINT}
	mount $"/dev/"${PARTITION} ${MOUNTPOINT}
    confirm_mount ${MOUNTPOINT}
	
	# Identify and create swap, if applicable
    dialog --backtitle "$VERSION" --title " Select SWAP Partition " --menu "\n." 12 40 4 ${PARTITIONS} $"none" $"-" 2>${ANSWER} || config_base_menu  
    if [[ $(cat ${ANSWER}) != "none" ]]; then
    
       PARTITION=$(cat ${ANSWER})
       
       #swapoff $"/dev/"${PARTITION}
       mkswap  $"/dev/"${PARTITION} >/dev/null 2>&1
       swapon  $"/dev/"${PARTITION} >/dev/null 2>&1
       
       PARTITIONS="$(echo $PARTITIONS | sed s/${PARTITION}$' -'//)"
       NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    fi
    
    ## Extra Step for VFAT UEFI Partition
    if [[ $UEFI -eq 1 ]]; then
    
       dialog --backtitle "$VERSION" --title " Select UEFI Partition " --menu "\n." 12 40 4 ${PARTITIONS} 2>${ANSWER} || config_base_menu  
       PARTITION=$(cat ${ANSWER})
       
       ## If there is already a fat/vfat partition...
       if [[ $(fsck -N /dev/$PARTITION | grep fat) ]]; then
          dialog --backtitle "$VERSION" --title " UEFI Partition " --yesno $"The UEFI partition $PARTITION has already been formatted.\n\nReformat? Doing so will erase ALL data already on that partition." 0 0 && mkfs.vfat -F32 $"/dev/"${PARTITION} >/dev/null 2>&1
       else 
          mkfs.vfat -F32 $"/dev/"${PARTITION} >/dev/null 2>&1
       fi   
       
       dialog --backtitle "$VERSION" --title " Select UEFI Mountpoint " --menu $"\n/boot is recommended, especially if intending to use the Gummiboot bootloader." 12 40 2 \
 	   "1" $"/boot" \
	   "2" $"/boot/efi" 2>${ANSWER}	
       
       case $(cat ${ANSWER}) in
        "1") UEFI_PART="/boot"
             ;;
        "2") UEFI_PART="/boot/efi"
             ;;
          *) config_base_menu
             ;;
       esac
       
       mkdir -p ${MOUNTPOINT}${UEFI_PART}
       mount $"/dev/"${PARTITION} ${MOUNTPOINT}${UEFI_PART}
       confirm_mount ${MOUNTPOINT}${UEFI_PART}     
       
    fi
    
    ## All other partitions
       while [[ $NUMBER_PARTITIONS > 0 ]]; do 
             dialog --backtitle "$VERSION" --title " Select Partition " --menu "\n." 12 40 4 ${PARTITIONS} $"done" $"-" 2>${ANSWER} || config_base_menu 
             PARTITION=$(cat ${ANSWER})
             
             if [[ $PARTITION == "done" ]]; then
                break;
             else
                MOUNT=""
                
                select_filesystem
	            if [[ $FILESYSTEM != "skip" ]]; then	
	               ${FILESYSTEM} $"/dev/"${PARTITION} >/dev/null 2>&1
	            fi
                
                dialog --backtitle "$VERSION" --title " Name Partition: $PARTITON " --inputbox "\nExamples include: /boot or /home.\n\nEnsure the name is preceeded by a forward slash (/)." 11 65 "/" 2>${ANSWER} || config_base_menu
                MOUNT=$(cat ${ANSWER})
                
                mkdir -p ${MOUNTPOINT}${MOUNT}
                mount $"/dev/"${PARTITION} ${MOUNTPOINT}${MOUNT}
                confirm_mount ${MOUNTPOINT}${MOUNT}
             fi
       done
}	
	
######################################################################
##																	##
##                    Installation Functions						##
##																	##
######################################################################	

install_base() {

    if [[ -n $(dmidecode --type 1 | grep VirtualBox) ]]; then
       dialog --backtitle "$VERSION" --title " Installation Note " --msgbox "\nThe base-devel package group will be required to use the Arch User Repository (AUR).\n\nThe Long Term Support (LTS) Kernel will require a one-off series of commands to load the necessary modules AFTER booting the installed system:\n\n$ su\n# depmod -a\n# modprobe -a vboxvideo vboxguest vboxsf\n# reboot" 17 55
    else
       dialog --backtitle "$VERSION" --title " Installation Note " --msgbox "\nWhere a wireless device has been detected, packages to support it will be installed automatically.\n\nThe base-devel package group will be required to use the Arch User Repository (AUR)." 20 55
    fi
    
    dialog --backtitle "$VERSION" --title " Install Base " \
    --menu $"\nThe latest kernel supports newer hardware. The LTS kernel is more stable, and is supported far longer.\n" 14 40 4 \
 	"1" $"Latest Kernel" \
	"2" $"Latest Kernel & base-devel" \
	"3" $"LTS Kernel" \
	"4" $"LTS Kernel & base-devel" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") # Latest Kernel
             clear
             pacstrap ${MOUNTPOINT} base btrfs-progs ntp sudo 
             ;;
        "2") # Latest Kernel and base-devel
             pacstrap ${MOUNTPOINT} base base-devel btrfs-progs ntp sudo
             ;;
        "3") # LTS Kernel
             pacstrap ${MOUNTPOINT} bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses linux-lts logrotate lvm2 man-db man-pages mdadm nano netctl pacman pciutils pcmciautils perl procps-ng psmisc reiserfsprogs s-nail sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi which xfsprogs btrfs-progs ntp sudo
             LTS=1
             ;;
        "4") # LTS Kernel and base-devel
             pacstrap ${MOUNTPOINT} bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses linux-lts logrotate lvm2 man-db man-pages mdadm nano netctl pacman pciutils pcmciautils perl procps-ng psmisc reiserfsprogs s-nail sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi which xfsprogs base-devel btrfs-progs ntp sudo
             LTS=1
             ;;
          *) install_base_menu
             ;;
    esac  	

  #check for a wireless device
  WIRELESS_DEV=`ip link | grep wlp | awk '{print $2}'| sed 's/://' | sed '1!d'`
  if [[ -n $WIRELESS_DEV ]]; then
     dialog --backtitle "$VERSION - $SYSTEM" --title " Wireless Device Detected " --infobox "\nInstalling supplementary wireless packages..." 7 40 
     sleep 2
     clear
     pacstrap ${MOUNTPOINT} iw wireless_tools wpa_actiond wpa_supplicant dialog
  fi

}

# Adapted from AIS. Integrated the configuration elements, and for UEFI systems, fixed the 
# gummiboot installation, dropped syslinux and replaced it with rEFInd.
install_bootloader() {
	
# FIX SYSLINUX
bios_bootloader() {
   dialog --backtitle "$VERSION" --title " Install Bootloader (BIOS) " \
    --menu $"\nGrub2 is recommended for beginners as the most popular and versatile option.\n\nSyslinux is a lighter and simpler alternative, usually used by Linux installation ISOs." 14 50 2 \
 	"1" $"Install Grub2" \
	"2" $"Install Syslinux" 2>${ANSWER}	
	case $(cat ${ANSWER}) in
        "1") clear
             pacstrap ${MOUNTPOINT} grub os-prober
             arch_chroot "grub-install --target=i386-pc --recheck ${INST_DEV}"
             arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg"
             ;;
        "2") clear
             pacstrap ${MOUNTPOINT} syslinux
             arch_chroot "syslinux-install_update -iam"
             sed -i "s/sda[0-9]/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             # If the LTS kernel has been installed amend the config file accordingly
             [[ $LTS -eq 1 ]] && sed -i 's/linux/linux-lts/g' ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             dialog --title " Syslinux Configuration Check " --msgbox "\nPlease check the syslinux configuration file.\n\nIt should contain the command:\nAPPEND root=/dev/$ROOT_PART rw\n" 10 50
             gksu leafpad ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
             ;;
          *) install_base_menu
             ;;
    esac  
}

uefi_bootloader() {

    #Ensure efivarfs is mounted (due to unmounting undertaken during the partitioning stage)
    dialog --backtitle "$VERSION - $SYSTEM" --title " Configuring UEFI " --infobox "\nEnsuring efivars is mounted..." 7 40 
    sleep 2
	[[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars
     
    dialog --backtitle "$VERSION" --title " Install Bootloader (UEFI) " \
    --menu $"\nGrub2 is recommended for beginners as the most popular and versatile option.\n\nGummiboot is a popular choice for UEFI systems, and recommends mounting the UEFI partition at /boot.\n\nrEFInd is a simple and fully automated alternative." 17 55 3 \
 	"1" $"Install Grub2" \
	"2" $"Install Gummiboot" \
	"3" $"Install rEFInd" 2>${ANSWER}	
	case $(cat ${ANSWER}) in
        "1") clear
             pacstrap ${MOUNTPOINT} grub os-prober
             arch_chroot "grub-install --target=x86_64-efi --efi-directory=${UEFI_PART} --bootloader-id=arch_grub --recheck"
             ;;
        "2") clear
             pacstrap ${MOUNTPOINT} gummiboot
             arch_chroot "gummiboot --path=${UEFI_PART} install"
             partuuid=`blkid -s PARTUUID ${ROOT_PART} | awk '{print $2}' | sed 's/"//g' | sed 's/^.*=//'`
             echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=PARTUUID=${partuuid} rw" > ${MOUNTPOINT}/boot/loader/entries/arch.conf
             echo -e "default  arch\ntimeout  4" > ${MOUNTPOINT}${UEFI_PART}/loader/loader.conf
             dialog --title " Gummiboot Configuration Check " --msgbox "\nPlease check the arch and loader configuration files.\n" 8 40
             gksu leafpad ${MOUNTPOINT}${UEFI_PART}/loader/entries/arch.conf
             gksu leafpad ${MOUNTPOINT}${UEFI_PART}/loader/loader.conf
             ;;
         "3") clear
              pactrap ${MOUNTPOINT} refind-efi
              arch_chroot "refind-install"
              ;;
          *) install_base_menu
             ;;
    esac 
    
    dialog --backtitle "$VERSION - $SYSTEM" --title " UEFI Tools " --infobox "\nInstalling supplementary UEFI packages..." 7 40 
    sleep 2
    clear
    pacstrap ${MOUNTPOINT} efibootmgr dosfstools 
}

    if [[ $UEFI -eq 0 ]]; then
       bios_bootloader
    else
       uefi_bootloader
    fi
}

# Install alsa, xorg and input drivers
# Also use the xkbmap set earlier to create a keyboard configuration file for the installed system
install_alsa_xorg_input() {

  dialog --backtitle "$VERSION" --title " ALSA, Xorg, and Input " --msgbox "\nBefore installing graphics card driver(s) or desktop environments, other packages are needed first:\n\nalsa - Advanced Linux Sound Architecture\nxorg-* - open-source X window system for graphics\nxf86-input-* - open-source drivers for input devices" 12 60
  clear	
  pacstrap ${MOUNTPOINT} alsa-utils xorg-server xorg-server-utils xorg-xinit xf86-input-synaptics xf86-input-keyboard xf86-input-vmmouse
  echo -e "Section "\"InputClass"\"\nIdentifier "\"system-keyboard"\"\nMatchIsKeyboard "\"on"\"\nOption "\"XkbLayout"\" "\"${XKBMAP}"\"\nEndSection" > ${MOUNTPOINT}/etc/X11/xorg.conf.d/00-keyboard.conf

}



setup_graphics_card() {

# basically this is used to manually set the GC_DETECTED variable
gc_driver_menu() {

   dialog --backtitle "$VERSION" --title " Graphics Card Menu " \
    --menu $"\nIf you are unsure - or your card is not listed - pick 'Unknown / All', which will install all listed drivers. At least one of them worked to boot Evo!\n" 17 50 7 \
 	"1" $"AMD/ATI" \
	"2" $"Intel" \
	"3" $"NVIDIA" \
	"4" $"Via" \
	"5" $"VirtualBox" \
    "6" $"VMWare" \
	"7" $"Unknown / All" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") GC_DETECTED="ATI"
             ;;
        "2") GC_DETECTED="Intel"
             ;;
        "3") GC_DETECTED="NVIDIA"
             ;;
        "4") GC_DETECTED="Via"
             ;;            
        "5") GC_DETECTED="VirtualBox"
             ;;
        "6") GC_DETECTED="VMware"
             ;;
        "7") GC_DETECTED="all"
             ;;
          *) install_desktop_menu
             ;;
    esac  
    install_gc
}

# Adapted from Anterogos' CLI installer (2.0)
detect_graphics_card() {
	
    if   [[ `echo ${GRAPHIC_CARD}|grep -i 'ati[[:space:]]'` != "" ]]; then
         GC_DETECTED="ATI" 
    elif [[ `echo ${GRAPHIC_CARD}|grep -i 'nvidia[[:space:]]'` != "" ]]; then
         GC_DETECTED="NVIDIA" 
    elif [[ `echo ${GRAPHIC_CARD}|grep -i 'intel[[:space:]]'` != "" ]] || [ `echo ${GRAPHIC_CARD}|grep -i 'lenovo[[:space:]]'` != "" ]]; then
         GC_DETECTED="Intel"
    elif [[ `echo ${GRAPHIC_CARD}|grep -i 'virtualbox[[:space:]]'` != "" ]]; then
         GC_DETECTED="VirtualBox"
    elif [[ `echo ${GRAPHIC_CARD}|grep -i 'vmware[[:space:]]'` != "" ]]; then
         GC_DETECTED="VMware"
    elif [[ `echo ${GRAPHIC_CARD}|grep -i 'via[[:space:]]'` != "" ]]; then
         GC_DETECTED="Via"
    else
         GC_DETECTED="Unknown"
    fi

}

install_gc() {

 clear
 if   [[ $GC_DETECTED == "ATI" ]]; then
      pacstrap ${MOUNTPOINT} xf86-video-ati ati-dri mesa-libgl mesa
      sed -i 's/^MODULES=(/MODULES=(radeon /' ${MOUNTPOINT}/etc/mkinitcpio.conf
 elif [[ $GC_DETECTED == "NVIDIA" ]]; then
      pacstrap ${MOUNTPOINT} xf86-video-nouveau nouveau-dri mesa-libgl mesa
      sed -i 's/^MODULES=(/MODULES=(nouveau /' ${MOUNTPOINT}/etc/mkinitcpio.conf
 elif [[ $GC_DETECTED == "Intel" ]]; then
      pacstrap ${MOUNTPOINT} xf86-video-intel intel-dri libva-intel-driver mesa-libgl mesa
      sed -i 's/^MODULES=(/MODULES=(i915 /' ${MOUNTPOINT}/etc/mkinitcpio.conf
 elif [[ $GC_DETECTED == "VirtualBox" ]]; then
      if [[ $LTS -eq 1 ]]; then
         dialog --backtitle "$VERSION" --title " VirtualBox Detected " --msgbox "\nAs the LTS kernel has been installed, the configuration process can only be semi-automated.\n\nA one-off series of commands to load the necessary modules for VirtualBox will be required AFTER booting the installed system:\n\n$ su\n# depmod -a\n# modprobe -a vboxvideo vboxguest vboxsf\n# reboot" 17 55
         pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-modules-lts mesa-libgl
      else
         pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-modules mesa-libgl   
         arch_chroot "modprobe -a vboxguest vboxsf vboxvideo"   
      fi
      # Enable vboxservice whatever the kernel type
      arch_chroot "systemctl enable vboxservice"
 elif [[ $GC_DETECTED == "VMWare" ]]; then
      pacstrap ${MOUNTPOINT} xf86-video-vmware mesa-libgl mesa
 elif [[ $GC_DETECTED == "Via" ]]; then
      pacstrap ${MOUNTPOINT} xf86-video-openchrome
 elif [[ $GC_DETECTED == "all" ]]; then 
      pacstrap ${MOUNTPOINT} xf86-video-ati ati-dri xf86-video-nouveau nouveau-dri xf86-video-intel intel-dri xf86-video-fbdev xf86-video-vmware xf86-video-openchrome mesa-libgl mesa      
 else
      gc_driver_menu  
 fi

}

    detect_graphics_card
    if [[ $GC_DETECTED == "Unknown" ]]; then
       gc_driver_menu
    else
       dialog --backtitle "$VERSION" --title " $GC_DETECTED Detected " --yesno "\nIs your graphics card $GC_DETECTED?\n\n-Select 'Yes' to install its open-source driver.\n-Select 'No' to open the graphics card menu." 10 55 && install_gc || gc_driver_menu
    fi

}

install_de_wm() {

   # Only show this information box once
   if [[ $SHOW_ONCE -eq 0 ]]; then
      dialog --backtitle "$VERSION" --title " Install Desktop Environments " --msgbox "\nThis option can be repeated to install multiple environments.\n\nGnome, KDE, and LXDE come with a display manager.\n\nCinnamon, Gnome and KDE come with a Network Manager.\n" 13 55
   fi
   
	dialog --backtitle "$VERSION" --title " Install Desktop Environments  " \
    --menu "\nDesktop Environments are listed first, and may have multiple download options.\n\nKDE is a 750MB+ download." 19 45 8 \
 	"1" $"Cinnamon" \
	"2" $"Enlightenment" \
	"3" $"Gnome-Shell (minimal)" \
	"4" $"Gnome" \
	"5" $"Gnome + Extras" \
    "6" $"KDE Base (minimal)" \
    "7" $"KDE" \
    "8" $"LXDE" \
    "9" $"MATE" \
    "10" $"MATE + Extras" \
    "11" $"Xfce" \
    "12" $"Xfce + extras" \
    "13" $"Awesome WM" \
    "14" $"Fluxbox WM" \
	"15" $"i3 WM" \
    "16" $"Ice WM" \
    "17" $"Openbox WM" \
    "18" $"Pek WM" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") # Cinnamon
             clear
             pacstrap ${MOUNTPOINT} cinnamon
             ;;
        "2") # Enlightement
             clear
             pacstrap ${MOUNTPOINT} enlightenment terminology lxpolkit
             ;;
        "3") # Gnome-Shell
             clear
             pacstrap ${MOUNTPOINT} gnome-shell gdm
             GNOME_INSTALLED=1
             ;;
        "4") # Gnome
             clear
             pacstrap ${MOUNTPOINT} gnome rp-pppoe

             if [[ $NM_INSTALLED -eq 0 ]]; then         
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service"
                NM_INSTALLED=1
             fi
           
             GNOME_INSTALLED=1
             ;;            
        "5") # Gnome + Extras
             clear
             pacstrap ${MOUNTPOINT} gnome gnome-extra rp-pppoe

             if [[ $NM_INSTALLED -eq 0 ]]; then         
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service"
                NM_INSTALLED=1
             fi
           
             GNOME_INSTALLED=1
             ;;
        "6") # KDE BASE
             clear
             pacstrap ${MOUNTPOINT} kdebase-workspace kdeplasma-applets-plasma-nm
             KDE_INSTALLED=1
             ;;
        "7") # KDE 
             clear
             pacstrap ${MOUNTPOINT} kde kdeplasma-applets-plasma-nm xdg-user-dirs xdg-utils rp-pppoe

             if [[ $NM_INSTALLED -eq 0 ]]; then          
                arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service"
                NM_INSTALLED=1
             fi
               
             KDE_INSTALLED=1
             ;;
         "8") # LXDE
              clear
              pacstrap ${MOUNTPOINT} lxde
              LXDE_INSTALLED=1
             ;;
         "9") # MATE
              clear
              pacstrap ${MOUNTPOINT} mate
             ;;
        "10") # MATE + Extras
               clear
               pacstrap ${MOUNTPOINT} mate mate-extra
             ;;                 
        "11") # Xfce
              clear
              pacstrap ${MOUNTPOINT} xfce4 lxpolkit
             ;;            
        "12") # Xfce + Extras
              clear
              pacstrap ${MOUNTPOINT} xfce4 xfce4-goodies lxpolkit
             ;;
        "13") # Awesome
              clear
              pacstrap ${MOUNTPOINT} awesome vicious lxpolkit
             ;;
        "14") #Fluxbox
              clear 
              pacstrap ${MOUNTPOINT} fluxbox fbnews fluxter lxpolkit
             ;; 
        "15") #i3
              clear
              pacstrap ${MOUNTPOINT} i3-wm i3lock i3status lxpolkit
             ;; 
        "16") #IceWM
              clear
              pacstrap ${MOUNTPOINT} icewm icewm-themes lxpolkit
             ;; 
        "17") #Openbox
              clear
              pacstrap ${MOUNTPOINT} openbox openbox-themes lxpolkit
             ;; 
        "18") #PekWM
              clear
              pacstrap ${MOUNTPOINT} pekwm pekwm-themes lxpolkit 
             ;;            
          *) install_desktop_menu
             ;;
    esac  
    
    # Offer to install common packages
    if [[ $COMMON_INSTALLED -eq 0 ]]; then
       dialog --backtitle "$VERSION" --title " Install Common Packges? " --yesno "\nSome environments require common files to be installed, particularly for permissions, creation of home folders, and file manager functionality.\n\nPackages include: xterm, xdg-user-dirs, gksu, gnome-keyring, polkit, gvfs, and the gnome-icon-theme, etc. Those installing the full KDE desktop alone will not need to install these.\n\nThis option will only be presented ONCE.\n" 16 60 \
       && clear && pacstrap ${MOUNTPOINT} xterm gksu gnome-keyring polkit xdg-user-dirs xdg-utils gamin gvfs gvfs-afc gvfs-smb ttf-dejavu gnome-icon-theme python2-xdg
    fi
    
    # Either way, the option will no longer be presented.
    COMMON_INSTALLED=1

}

# Determine if LXDE, Gnome, and/or KDE has been installed, and act accordingly.
install_dm() {

 if 	[[ $DM_INSTALLED -eq 0 ]]; then
	
         if    [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 0 ]]; then
               arch_chroot "systemctl enable kdm.service"
               dialog --backtitle "$VERSION" --title " KDM Enabled " --msgbox "\nAs KDE has been installed, its native display manager - KDM - has now been enabled.\n" 9 35
    
         elif  [[ $KDE_INSTALLED -eq 0 ]] && [[ $GNOME_INSTALLED -eq 1 ]]; then
               arch_chroot "systemctl enable gdm.service"
               dialog --backtitle "$VERSION" --title " GDM Enabled " --msgbox "\nAs Gnome has been installed, its native display manager - GDM - has now been enabled.\n" 9 35

         elif  [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 1 ]]; then
         
               dialog --backtitle "$VERSION" --title " Choose GDM or KDM " \
               --menu $"\nBoth Gnome and KDE have been installed. Please select your preferred display manager.\n" 12 45 2 \
 	           "1" $"GDM (Gnome)" \
	           "2" $"KDM (KDE)" 2>${ANSWER}	
	
	          case $(cat ${ANSWER}) in
              "1") arch_chroot "systemctl enable gdm.service" 
                ;;
              "2") arch_chroot "systemctl enable kdm.service"
                ;;
                *) install_desktop_menu
                ;;
              esac 
         
         elif [[ $LXDE_INSTALLED -eq 1 ]]; then
              arch_chroot "systemctl enable lxdm.service"
              dialog --backtitle "$VERSION" --title " LXDM Enabled " --msgbox "\nAs LXDE has been installed, its native display manager - LXDM - has now been enabled." 9 35
         
         else 
               dialog --backtitle "$VERSION" --title " Choose Display Manager " \
               --menu $"\nPlease choose between LXDM or LightDM. LXDM is recommended for beginners.\n" 11 45 2 \
 	           "1" $"LXDM" \
	           "2" $"LightDM" 2>${ANSWER}	
	
	          case $(cat ${ANSWER}) in
              "1") # LXDM
                   clear
                   pacstrap ${MOUNTPOINT} lxdm
                   arch_chroot "systemctl enable lxdm.service" 
                ;;
              "2") # LIGHTDM
                   clear
                   pacstrap ${MOUNTPOINT} lightdm lightdm-gtk3-greeter
                   arch_chroot "systemctl enable lightdm.service"
                ;;
                *) install_desktop_menu
                ;;
              esac 
         fi
         
         # Ensure DM option can only be run once.
         DM_INSTALLED=1
         
   # if A display manager has already been installed and enabled (DM_INSTALLED=1), show a message instead.
   else  
         dialog --backtitle "$VERSION" --title " Display Manager Installed " --msgbox "\nA display manager has already been installed and enabled." 9 35
   fi       

}

install_nm() {

   if [[ $NM_INSTALLED -eq 0 ]]; then
      dialog --backtitle "$VERSION" --title " Choose Network Manager " \
      --menu $"\nNetwork Manager is recommended, especially for wireless and PPPoE/DSL connections.\n" 14 45 4 \
 	  "1" $"Connman (command line)" \
	  "2" $"dhcpcd  (command line)" \
	  "3" $"Network Manager (graphical)" \
	  "4" $"WICD (graphical)" 2>${ANSWER}	
	
	  case $(cat ${ANSWER}) in
      "1") # connman
           clear
           pacstrap ${MOUNTPOINT} connman 
           arch_chroot "systemctl enable connman.service" 
           ;;
      "2") # dhcpcd
           clear
           arch_chroot "systemctl enable dhcpcd.service"
           ;;
      "3") # Network Manager
           clear
           pacstrap ${MOUNTPOINT} networkmanager network-manager-applet rp-pppoe
           arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service"
           ;;
      "4") # WICD
           clear
           pacstrap ${MOUNTPOINT} wicd-gtk
           arch_chroot "systemctl enable wicd.service"
           ;;
        *) install_desktop_menu
           ;;
      esac   
      NM_INSTALLED=1
   
   else
      dialog --backtitle "$VERSION" --title " Network Manager Installed " --msgbox "\nA network connection manager has already been installed and enabled." 9 35
   fi
}


test() {
	
	
	     dialog --backtitle "$VERSION - $SYSTEM" --title " Wireless Device Detected " --infobox "\nInstalling supplementary wireless packages..." 7 40 
     sleep 3
	
	
	#ping -c 3 google.com > /tmp/.outfile &
    #dialog --title "checking" --no-kill --tailboxbg /tmp/.outfile 20 60 

}
	


######################################################################
##																	##
##                 Main Interfaces       							##
##																	##
######################################################################

# Greet the user when first starting the installer
greeting() {
id_system
dialog --backtitle "$VERSION - $SYSTEM ($ARCHI)" --title " Welcome to $VERSION " --yesno "\nHighlight options by pressing their numbers or by using the up/down arrow keys before pressing [enter] to confirm.\n\nSwitch between buttons by using [Tab] or the left/right arrow keys before pressing [enter] to confirm.\n\nA mouse/touchpad may also be used.\n\nA TUITION MODE is also availble for beginners, which will explain each step and make recommendations in more detail. Activate tuition mode?" 0 0 && TUITION_MODE=1	

}

# Preparation
prep_menu() {
   dialog --backtitle "$VERSION" --title " Prepare Installation " \
    --menu $"" 10 50 4 \
 	"1" $"Set Desktop Keyboard Layout" \
	"2" $"Configure Installer Mirrorlist (optional)" \
	"3" $"Partition Disk" \
	"4" $"Mount Partitions" 2>${ANSWER}

	case $(cat ${ANSWER}) in
        "1") set_xkbmap 
             ;;
        "2") configure_mirrorlist
             ;;
        "3") umount_partitions
             select_device
             create_partitions
             ;;
        "4") mount_partitions
             ;;        
          *) main_menu_online
             ;;
    esac
    
    prep_menu  	
	
}

# Base Installation
install_base_menu() {
   dialog --backtitle "$VERSION" --title " Install Base " \
    --menu $"" 8 40 2 \
 	"1" $"Install Base" \
	"2" $"Install Bootloader" 2>${ANSWER}	
	
	case $(cat ${ANSWER}) in
        "1") install_base 
             ;;
        "2") install_bootloader
             ;;
          *) main_menu_online
             ;;
    esac
    
    install_base_menu 	
}

# Base Configuration
config_base_menu() {
    dialog --backtitle "$VERSION" --title " Configure Base" \
    --menu $"" 12 50 6 \
 	"1" $"Generate FSTAB" \
	"2" $"Set Hostname" \
	"3" $"Set Timezone" \
	"4" $"Set Hardware Clock" \
	"5" $"Set System Locale" \
	"6" $"Set Virtual Console" 2>${ANSWER}	
	
	case $(cat ${ANSWER}) in
        "1") generate_fstab 
             ;;
        "2") set_hostname
             ;;
        "3") set_timezone
             ;;
        "4") set_hw_clock
             ;;            
        "5") set_locale
             ;;
        "6") set_keymap
             ;;            
          *) main_menu_online
             ;;
    esac
    
    config_base_menu

}

# Root and User Configuration
config_user_menu() {	
    dialog --backtitle "$VERSION" --title " Configure User(s)" \
    --menu $"" 8 50 2 \
 	"1" $"Set Root Pasword" \
	"2" $"Add New User(s)" 2>${ANSWER}
	
		case $(cat ${ANSWER}) in
        "1") set_root_password 
             ;;
        "2") create_new_user
             ;;     
          *) main_menu_online
             ;;
    esac
    
    config_user_menu
}


install_desktop_menu() {
	
    dialog --backtitle "$VERSION" --title " Install Desktop " \
    --menu $"" 10 55 4 \
 	"1" $"Install Graphics, Input, and Sound Drivers" \
	"2" $"Install Desktop Environment(s)" \
	"3" $"Install Network Management" \
	"4" $"Install Display Manager" 2>${ANSWER}
	
	case $(cat ${ANSWER}) in
        "1") install_alsa_xorg_input
             setup_graphics_card 
             ;;
        "2") install_de_wm
             ;;
        "3") install_nm
             ;;
        "4") install_dm
             ;;            
          *) main_menu_online
             ;;
    esac
    
    install_desktop_menu
	
}

main_menu_online() {
    dialog --backtitle "$VERSION" --title " Main Menu - Online Mode " \
    --menu $"\nEach step can be repeated, but must be followed IN ORDER.Once complete, select Done\n" 17 50 7 \
 	"1" $"Prepare Installation" \
	"2" $"Install Base" \
	"3" $"Configure Base" \
	"4" $"Configure User Account(s)" \
	"5" $"Install Desktop(s)" \
    "6" $"Run Mkinitcpio" \
	"7" $"Done" 2>${ANSWER}

   case $(cat ${ANSWER}) in
        "1") prep_menu 
             ;;
        "2") install_base_menu
             ;;
        "3") config_base_menu
             ;;
        "4") config_user_menu
             ;;            
        "5") install_desktop_menu
             ;;
        "6") run_mkinitcpio
             ;;            
          *) (dialog --yesno $"Close installer?" 0 0) && umount_partitions && exit 0 || main_menu_online
             ;;
    esac
    main_menu_online 

}

# Not used yet.
mode_menu() {

   dialog --backtitle "$VERSION" --title " Installation Mode " \
    --menu $"\nOn-line: Install the latest packages from the Arch repositories to build a custom system.\nInternet connection required.\n\nOff-line: Install Evo from this ISO.\nNo internet connection required.\n" 15 50 2 \
 	"1" $"On-line  Mode" \
	"2" $"Off-line Mode" 2>${ANSWER}
	MODE=$(cat ${ANSWER})
	
	while true; do
      if   [[ $MODE == "1" ]]; then
           main_menu_online
      elif [[ $MODE == "2" ]]; then
           dialog --msgbox $"This option is not available yet" 6 50 && mode_menu
      else         
          (dialog --yesno $"Close installer?" 0 0) && exit 0 || mode_menu
      fi         
     done
	
}

######################################################################
##																	##
##                        Execution     							##
##																	##
######################################################################

check_evo_requirements
id_system
greeting

	while true; do
          main_menu_online      
    done

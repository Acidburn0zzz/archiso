# !/bin/bash
#
# Lution-AIS installer (version 0.2 - August 2014)
#
# Based on the Arch Installation Script (AIS) and Arch Ultimate Installation 
# script (AUI) written by helmuthdu (helmuthdu[at]gmail[dot]com). Modified by
# Carl Duff for Evo/Lution Linux.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#-----------------------------------------------------------------------

##
## Set variables, colours, and prompts
##

# Menu and installation
  checklist=( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 )
  KDE_INSTALLED=0
  GNOME_INSTALLED=0
  LXDE_INSTALLED=0
  DM_INSTALLED=0
  COMMON_INSTALLED=0
  NM_INSTALLED=0
  KEYMAP_XKB="us"
  LTS=0

# Architecture
  ARCHI=`uname -m`
  UEFI=0
  LVM=0
  LUKS=0
  LUKS_DISK="sda2"
  EFI_DISK="/boot/efi"
  ROOT_DISK="/dev/sda1"
  BOOT_DISK="/dev/sda"

# COLORS
    Bold=$(tput bold)
    Underline=$(tput sgr 0 1)
    Reset=$(tput sgr0)
 
    Red=$(tput setaf 1)
    Green=$(tput setaf 2)
    Yellow=$(tput setaf 3)
    Blue=$(tput setaf 4)
    Purple=$(tput setaf 5)
    Cyan=$(tput setaf 6)
    White=$(tput setaf 7)
 
    BRed=${Bold}$(tput setaf 1)
    BGreen=${Bold}$(tput setaf 2)
    BYellow=${Bold}$(tput setaf 3)
    BBlue=${Bold}$(tput setaf 4)
    BPurple=${Bold}$(tput setaf 5)
    BCyan=${Bold}$(tput setaf 6)
    BWhite=${Bold}$(tput setaf 7)
  
# Prompts
    prompt1="Enter your option: "
    prompt2="Enter nÂ° of options (ex: 1 2 3 or 1-3): "
    prompt3="You have to manual enter the following commands, then press ${BYellow}ctrl+d${Reset} or type ${BYellow}exit${Reset}:"

# Current Directory
  AUI_DIR=`pwd`
  MOUNTPOINT="/mnt"

# Verbose mode
  [[ $1 == -v || $1 == --verbose ]] && VERBOSE_MODE=1 || VERBOSE_MODE=0

# Log file
  LOG="${AUI_DIR}/`basename ${0}`_error.log"
  [[ -f $LOG ]] && rm -f $LOG
  PKG=""
  PKG_FAIL="${AUI_DIR}/`basename ${0}`_pkg_fail_list.log"
  [[ -f $PKG_FAIL ]] && rm -f $PKG_FAIL


#
# Set common functions
#

 error_msg() { 
    local MSG="${1}"
    echo -e "${MSG}"
    exit 1
 } 

  cecho() { #{{{
    echo -e "$1"
    echo -e "$1" >>"$LOG"
    tput sgr0;
  }

  check_boot_system() {
    if [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Inc.' ]] || [[ "$(cat /sys/class/dmi/id/sys_vendor)" == 'Apple Computer, Inc.' ]]; then
      modprobe -r -q efivars || true  # if MAC
    else
      modprobe -q efivarfs            # all others
    fi
    if [[ -d "/sys/firmware/efi/" ]]; then
      ## Mount efivarfs if it is not already mounted
      if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
        mount -t efivarfs efivarfs /sys/firmware/efi/efivars
      fi
      UEFI=1
      echo "UEFI Mode detected"
    else
      UEFI=0
      echo "BIOS Mode detected"
    fi
  }

  read_input() {
      read -p "$prompt1" OPTION
  }
  
  read_input_text() {
      read -p "$1 [y/N]: " OPTION
      echo ""
    OPTION=`echo "$OPTION" | tr '[:upper:]' '[:lower:]'`
  } 

 read_input_options() {
    local line
    local packages
    if [[ $AUTOMATIC_MODE -eq 1 ]]; then
      array=("$1")
    else
      read -p "$prompt2" OPTION
      array=("$OPTION")
    fi
    for line in ${array[@]/,/ }; do
      if [[ ${line/-/} != $line ]]; then
        for ((i=${line%-*}; i<=${line#*-}; i++)); do
          packages+=($i);
        done
      else
        packages+=($line)
      fi
    done
    OPTIONS=("${packages[@]}")
  }

  print_line() { 
    printf "%$(tput cols)s\n"|tr ' ' '-'
  }
  print_title() {
    clear
    print_line
    echo -e "# ${BBlue}$1${Reset}"
    print_line
    echo ""
  }
  
  print_info() {
    #Console width number
    T_COLS=`tput cols`
    echo -e "${Bold}$1${Reset}\n" | fold -sw $(( $T_COLS - 18 )) | sed 's/^/\t/'
  }
 
   print_info_light() {
    #Console width number
    T_COLS=`tput cols`
    echo -e "$1\n" | fold -sw $(( $T_COLS - 18 )) | sed 's/^/\t/'
  }
 
  print_warning() {
    T_COLS=`tput cols`
    echo -e "${BYellow}$1${Reset}\n" | fold -sw $(( $T_COLS - 1 ))
  }
  
  print_danger() {
    T_COLS=`tput cols`
    echo -e "${BRed}$1${Reset}\n" | fold -sw $(( $T_COLS - 1 ))
  }

  checkbox() {
    #display [X] or [ ]
    [[ "$1" -eq 1 ]] && echo -e "${BGreen}(${Reset}${Bold}#${BGreen})${Reset}" || echo -e "${BRed}( ${BRed})${Reset}";
  }

  contains_element() {
    #check if an element exist in a string
    for e in "${@:2}"; do [[ $e == $1 ]] && break; done;
  }

 invalid_option() {
    print_line
    echo "Invalid option. Try another one."
    pause_function
  }
  
  pause_function() {
    print_line
      read -e -sn 1 -p "Press enter to continue..."
  }

  mainmenu_item() { #{{{
    echo -e "$(checkbox "$1") ${Bold}$2${Reset}"
  }

 arch_chroot() {
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}"
  }
 
  getkeymap_xkb() {
    local keymaps_xkb=("af - Afghani" "al - Albanian" "et - Amharic" "ma - Arabic (Morocco)" "sy - Arabic (Syria)" "am - Armenian" "az - Azerbaijani" "ml - Bambara" "by - Belarusian" "be - Belgian" "bd - Bangla" "ba - Bosnian" "bg - Bulgarian" "mm - Burmese" "cn - Chinese" "hr - Croatian" "cz - Czech" "dk - Danish" "mv - Dhivehi" "nl - Dutch" "bt - Dzongkha" "cm - English (Cameroon)" "gh - English (Ghana)" "ng - English (Nigeria)" "za - English (South Africa)" "gb - English (UK)" "us - English (US)" "ee - Estonian" "fo - Faroese" "ph - Filipino" "fi - Finnish" "fr - French" "ca - French (Canada)" "cd - French (DR Congo)" "gn - French (Guinea)" "ge - Georgian" "de - German" "at - German (Austria)" "ch - German (Switzerland)" "gr - Greek" "il - Hebrew" "hu - Hungarian" "is - Icelandic" "in - Indian" "iq - Iraqi" "it - Italian" "ie - Irish" "jp - Japanese" "kz - Kazakh" "kh - Khmer (Cambodia)" "kr - Korean" "kg - Kyrgyz" "lv - Latvian" "la - Lao" "lt - Lithuanian" "mk - Macedonian" "mt - Maltese" "md - Moldavian" "mn - Mongolian" "me - Montenegrin" "np - Nepali" "no - Norwegian" "ir - Persian" "pl - Polish" "pt - Portuguese" "br - Portuguese (Brazil)" "ro - Romanian" "ru - Russian" "rs - Serbian" "si - Slovenian" "sk - Slovak" "es - Spanish" "se - Swedish" "tz - Swahili (Tanzania)" "ke - Swahili (Kenya)" "tw - Taiwanese" "tj - Tajik" "th - Thai" "bw - Tswana" "tr - Turkish" "tm - Turkmen" "ua - Ukrainian" "pk - Urdu (Pakistan)" "uz - Uzbek" "vn - Vietnamese" "sn - Wolof")
    PS3="(shift+pgup/pgdown) $prompt1"
    echo "Select keymap:"
    select KEYMAP_XKB in "${keymaps_xkb[@]}"; do
      if contains_element "$KEYMAP_XKB" "${keymaps_xkb[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }

  getkeymap() { 
    local keymaps=(`localectl list-keymaps`)
    PS3="(shift+pgup/pgdown) $prompt1"
    echo "Select keymap:"
    select KEYMAP in "${keymaps[@]}"; do
      if contains_element "$KEYMAP" "${keymaps[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }

 setlocale() {
    local locale_list=(`cat /etc/locale.gen | grep UTF-8 | sed 's/\..*$//' | sed '/@/d' | awk '{print $1}' | uniq | sed 's/#//g'`);
    PS3="$prompt1"
    echo "Select locale:"
    select LOCALE in "${locale_list[@]}"; do
      if contains_element "$LOCALE" "${locale_list[@]}"; then
        LOCALE_UTF8="${LOCALE}.UTF-8"
        break
      else
        invalid_option
      fi
    done
  }
  

  settimezone() {
    local zone=(`timedatectl list-timezones | sed 's/\/.*$//' | uniq`);
    PS3="$prompt1"
    echo "Select zone:"
    select ZONE in "${zone[@]}"; do
      if contains_element "$ZONE" "${zone[@]}"; then
        local subzone=(`timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///'`)
        PS3="$prompt1"
        echo "Select subzone:"
        select SUBZONE in "${subzone[@]}"; do
          if contains_element "$SUBZONE" "${subzone[@]}"; then
            break
          else
            invalid_option
          fi
        done
        break
      else
        invalid_option
      fi
    done
  }

check_evo_requirements() {

  if  [[ `whoami` != "root" ]]; 
  then
    print_danger "This script must be run with root privilages (i.e. the 'sudo' command)."
    pause_function
    exit 1
  fi

  if ! [ "`ping -c 1 google.com`" ]; 
  then
    echo 
    print_danger "Connection test failed. You must run this script with an active internet connection."
    pause_function
    exit 1
  fi
}


# SELECT KEYMAP - SETXKBMAP
# Modified by Carl Duff to use the 'setxkbmap' command rather than 'loadkeys' for the installer terminal.
select_keymap_xkb(){
  print_title "INSTALLER KEYBOARD LAYOUT"
  print_info "The setxkbmap command defines the keyboard keymap to be used in this terminal. It will also be used to set the keyboard layout for your installed desktop environment(s) / window manager(s), where installed."
  pause_function
  OPTION=n
  while [[ $OPTION != y ]]; do
    getkeymap_xkb
    read_input_text "Confirm keymap: $KEYMAP_XKB"
  done
  setxkbmap ${KEYMAP_XKB:0:2}
}

#}}}
#MIRRORLIST {{{
configure_mirrorlist(){
  local countries_code=("AU" "AT" "BY" "BE" "BR" "BG" "CA" "CL" "CN" "CO" "CZ" "DK" "EE" "FI" "FR" "DE" "GR" "HU" "IN" "IE" "IL" "IT" "JP" "KZ" "KR" "LV" "LU" "MK" "NL" "NC" "NZ" "NO" "PL" "PT" "RO" "RU" "RS" "SG" "SK" "ZA" "ES" "LK" "SE" "CH" "TW" "TR" "UA" "GB" "US" "UZ" "VN")
  local countries_name=("Australia" "Austria" "Belarus" "Belgium" "Brazil" "Bulgaria" "Canada" "Chile" "China" "Colombia" "Czech Republic" "Denmark" "Estonia" "Finland" "France" "Germany" "Greece" "Hungary" "India" "Ireland" "Israel" "Italy" "Japan" "Kazakhstan" "Korea" "Latvia" "Luxembourg" "Macedonia" "Netherlands" "New Caledonia" "New Zealand" "Norway" "Poland" "Portugal" "Romania" "Russian" "Serbia" "Singapore" "Slovakia" "South Africa" "Spain" "Sri Lanka" "Sweden" "Switzerland" "Taiwan" "Turkey" "Ukraine" "United Kingdom" "United States" "Uzbekistan" "Viet Nam")
  country_list(){
    #`reflector --list-countries | sed 's/[0-9]//g' | sed 's/^/"/g' | sed 's/,.*//g' | sed 's/ *$//g'  | sed 's/$/"/g' | sed -e :a -e '$!N; s/\n/ /; ta'`
    PS3="$prompt1"
    echo "Select your country:"
    select country_name in "${countries_name[@]}"; do
      if contains_element "$country_name" "${countries_name[@]}"; then
        contry_code=${countries_code[$(( $REPLY - 1 ))]}
        break
      else
        invalid_option
      fi
    done
  }
  print_title "CONFIGURE MIRRORLIST"
  print_info "This option can list the mirrors/servers available in your country, ranked by download speed."
  OPTION=n
  while [[ $OPTION != y ]]; do
    country_list
    read_input_text "Confirm country: $country_name"
  done

  url="https://www.archlinux.org/mirrorlist/?country=${contry_code}&use_mirror_status=on"

  tmpfile=$(mktemp --suffix=-mirrorlist)

  # Get latest mirror list and save to tmpfile
  curl -so ${tmpfile} ${url}
  sed -i 's/^#Server/Server/g' ${tmpfile}

  # Backup and replace current mirrorlist file (if new file is non-zero)
  if [[ -s ${tmpfile} ]]; then
   { echo " Backing up the original mirrorlist..."
     mv -i /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig; } &&
   { echo " Rotating the new list into place..."
     mv -i ${tmpfile} /etc/pacman.d/mirrorlist; }
  else
    echo " Unable to update, could not download list."
  fi
  # allow global read access (required for non-root yaourt execution)
  chmod +r /etc/pacman.d/mirrorlist
  gksu leafpad /etc/pacman.d/mirrorlist
}
#}}}
#UMOUNT PARTITIONS {{{
umount_partitions(){
  mounted_partitions=(`lsblk | grep ${MOUNTPOINT} | awk '{print $7}' | sort -r`)
  swapoff -a
  for i in ${mounted_partitions[@]}; do
    umount $i
  done
}
#}}}
#CREATE PARTITION SCHEME {{{
create_partition_scheme(){
  LUKS=0
  LVM=0
  select_device(){
    devices_list=(`lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd'`);
    PS3="$prompt1"
    echo -e "Select partition:\n"
    select device in "${devices_list[@]}"; do
      if contains_element "${device}" "${devices_list[@]}"; then
        break
      else
        invalid_option
      fi
    done
    BOOT_DISK=$device
  }
  print_title "PARTITION DISK"
  print_info "Partitioning logically divides a hard drive into seperate sections (e.g. boot, root, home, and swap)."
  print_info "Although partitioning is generally up to the user, UEFI systems MUST have a separate boot partition using filesystem FAT32."
  partition_layout=("Standard" "Plus LVM" "Plus Encryption and LVM")
  PS3="$prompt1"
  echo -e "Select partition scheme:"
  select OPT in "${partition_layout[@]}"; do
    case "$REPLY" in
      1)
        create_partition
        ;;
      2)
        create_partition
        setup_lvm
        ;;
      3)
        create_partition
        setup_luks
        setup_lvm
        ;;
      *)
        invalid_option
        ;;
    esac
    [[ -n $OPT ]] && break
  done
}
#}}}
#SETUP PARTITION{{{
# Modified by Carl Duff. Integrated Gparted, and dropped most of the other partitioning tools.
create_partition(){
  print_title "CHOOSE PARTITIONING TOOL"
  print_info "GParted is a user-friendly graphical tool that supports both BIOS and UEFI systems."
  print_info "Text-based tools available are cfdisk for BIOS systems (MBR), or gdisk for UEFI systems (GPT)."
  print_warning "It is not necessary to actually format the partitions created, as this will be undertaken later."
  apps_list=("gparted" "cfdisk" "gdisk");
  PS3="$prompt1"
  echo -e "Select partition program:"
  select OPT in "${apps_list[@]}"; do
    if contains_element "$OPT" "${apps_list[@]}"; then
      select_device
      case $OPT in
        gparted)
          gksu gparted ${device}
          ;;
        *)
          $OPT ${device}
          ;;
      esac
      break
    else
      invalid_option
    fi
  done
}
#}}}
#SETUP LUKS {{{
setup_luks(){
  print_title "SET UP ENCRYPTION"
  print_info "The Linux Unified Key Setup or LUKS is a disk-encryption specification created by Clemens Fruhwirth and originally intended for Linux."
  print_danger "\tDo not use this for boot partitions"
  block_list=(`lsblk | grep 'part' | awk '{print "/dev/" substr($1,3)}'`)
  PS3="$prompt1"
  echo -e "Select partition:"
  select OPT in "${block_list[@]}"; do
    if contains_element "$OPT" "${block_list[@]}"; then
      cryptsetup luksFormat $OPT
      cryptsetup open --type luks $OPT crypt
      LUKS=1
      LUKS_DISK=`echo ${OPT} | sed 's/\/dev\///'`
      break
    elif [[ $OPT == "Cancel" ]]; then
      break
    else
      invalid_option
    fi
  done
}
#}}}
#SETUP LVM {{{
setup_lvm(){
  print_title "SET UP LOGICAL VOLUME MANAGEMENT (LVM)"
  print_info "LVM is a logical volume manager for the Linux kernel; it manages disk drives and similar mass-storage devices. "
  print_warning "Last partition will take 100% of free space left"
  if [[ $LUKS -eq 1 ]]; then
    pvcreate /dev/mapper/crypt
    vgcreate lvm /dev/mapper/crypt
  else
    block_list=(`lsblk | grep 'part' | awk '{print "/dev/" substr($1,3)}'`)
    PS3="$prompt1"
    echo -e "Select partition:"
    select OPT in "${block_list[@]}"; do
      if contains_element "$OPT" "${block_list[@]}"; then
        pvcreate $OPT
        vgcreate lvm $OPT
        break
      else
        invalid_option
      fi
    done
  fi
  read -p "Enter number of partitions [ex: 2]: " number_partitions
  i=1
  while [[ $i -le $number_partitions ]]; do
    read -p "Enter $iÂª partition name [ex: home]: " partition_name
    if [[ $i -eq $number_partitions ]]; then
      lvcreate -l 100%FREE lvm -n ${partition_name}
    else
      read -p "Enter $iÂª partition size [ex: 25G, 200M]: " partition_size
      lvcreate -L ${partition_size} lvm -n ${partition_name}
    fi
    i=$(( i + 1 ))
  done
  LVM=1
}
#}}}
#SELECT|FORMAT PARTITIONS {{{
format_partitions(){
  print_title "FORMAT PARTITION(S)"
  print_info "This step will select and format the selected partiton(s) where Arch will be installed"
  print_danger "\tAll data on the ROOT and SWAP partition will be LOST."
  i=0

  block_list=(`lsblk | grep 'part\|lvm' | awk '{print substr($1,3)}'`)

  # check if there is no partition
  if [[ ${#block_list[@]} -eq 0 ]]; then
    print_danger "No partition found! Please re-check your partitions."
    pause_function
    create_partition
  fi

  partitions_list=()
  for OPT in ${block_list[@]}; do
    check_lvm=`echo $OPT | grep lvm`
    if [[ -z $check_lvm ]]; then
      partitions_list+=("/dev/$OPT")
    else
      partitions_list+=("/dev/mapper/$OPT")
    fi
  done

  # partitions based on boot system
  if [[ $UEFI -eq 1 ]]; then
    partition_name=("root" "EFI" "swap" "another")
  else
    partition_name=("root" "swap" "another")
  fi

  select_filesystem(){
    filesystems_list=( "btrfs" "ext2" "ext3" "ext4" "f2fs" "jfs" "nilfs2" "ntfs" "vfat" "xfs");
    PS3="$prompt1"
    echo -e "Select filesystem:\n"
    select filesystem in "${filesystems_list[@]}"; do
      if contains_element "${filesystem}" "${filesystems_list[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }

  disable_partition(){
    #remove the selected partition from list
    unset partitions_list[${partition_number}]
    partitions_list=(${partitions_list[@]})
    #increase i
    [[ ${partition_name[i]} != another ]] && i=$(( i + 1 ))
  }

  format_partition(){
    read_input_text "Confirm format $1 partition"
    if [[ $OPTION == y ]]; then
      [[ -z $3 ]] && select_filesystem || filesystem=$3
      mkfs.${filesystem} $1 \
        $([[ ${filesystem} == xfs || ${filesystem} == btrfs ]] && echo "-f") \
        $([[ ${filesystem} == vfat ]] && echo "-F32")
      fsck $1
      mkdir -p $2
      mount -t ${filesystem} $1 $2
      disable_partition
    fi
  }

  format_swap_partition(){
    read_input_text "Confirm format $1 partition"
    if [[ $OPTION == y ]]; then
      mkswap $1
      swapon $1
      disable_partition
    fi
  }

  create_swap(){
    swap_options=("partition" "file" "skip");
    PS3="$prompt1"
    echo -e "Select ${BYellow}${partition_name[i]}${Reset} filesystem:\n"
    select OPT in "${swap_options[@]}"; do
      case "$REPLY" in
        1)
          select partition in "${partitions_list[@]}"; do
            #get the selected number - 1
            partition_number=$(( $REPLY - 1 ))
            if contains_element "${partition}" "${partitions_list[@]}"; then
              format_swap_partition "${partition}"
            fi
            break
          done
          break
          ;;
        2)
          total_memory=`grep MemTotal /proc/meminfo | awk '{print $2/1024}' | sed 's/\..*//'`
          fallocate -l ${total_memory}M ${MOUNTPOINT}/swapfile
          chmod 600 ${MOUNTPOINT}/swapfile
          mkswap ${MOUNTPOINT}/swapfile
          swapon ${MOUNTPOINT}/swapfile
          i=$(( i + 1 ))
          break
          ;;
        3)
          i=$(( i + 1 ))
          break
          ;;
        *)
          invalid_option
          ;;
      esac
    done
  }

  check_mountpoint(){
    if mount | grep $2; then
      echo "Successfully mounted"
      disable_partition "$1"
    else
      echo "WARNING: Not Successfully mounted"
    fi
  }

  set_efi_partition(){
    efi_options=("/boot/efi" "/boot")
    PS3="$prompt1"
    echo -e "Select EFI mountpoint:\n"
    select EFI_DISK in "${efi_options[@]}"; do
      if contains_element "${EFI_DISK}" "${efi_options[@]}"; then
        break
      else
        invalid_option
      fi
    done
  }

  while true; do
    PS3="$prompt1"
    if [[ ${partition_name[i]} == swap ]]; then
      create_swap
    else
      echo -e "Select ${BYellow}${partition_name[i]}${Reset} partition:\n"
      select partition in "${partitions_list[@]}"; do
        #get the selected number - 1
        partition_number=$(( $REPLY - 1 ))
        if contains_element "${partition}" "${partitions_list[@]}"; then
          case ${partition_name[i]} in
            root)
              ROOT_PART=`echo ${partition} | sed 's/\/dev\/mapper\///' | sed 's/\/dev\///'`
              ROOT_DISK=${partition}
              format_partition "${partition}" "${MOUNTPOINT}"
              ;;
            EFI)
              set_efi_partition
              read_input_text "Format ${partition} partition"
              if [[ $OPTION == y ]]; then
                format_partition "${partition}" "${MOUNTPOINT}${EFI_DISK}" vfat
              else
                mkdir -p "${MOUNTPOINT}${EFI_DISK}"
                mount -t vfat "${partition}" "${MOUNTPOINT}${EFI_DISK}"
                check_mountpoint "${partition}" "${MOUNTPOINT}${EFI_DISK}"
              fi
              ;;
            another)
              read -p "Mountpoint [ex: /home]:" directory
              [[ $directory == "/boot" ]] && BOOT_DISK=`echo ${partition} | sed 's/[0-9]//'`
              select_filesystem
              read_input_text "Format ${partition} partition"
              if [[ $OPTION == y ]]; then
                format_partition "${partition}" "${MOUNTPOINT}${directory}" "${filesystem}"
              else
                read_input_text "Confirm fs="${filesystem}" part="${partition}" dir="${directory}""
                if [[ $OPTION == y ]]; then
                  mkdir -p ${MOUNTPOINT}${directory}
                  mount -t ${filesystem} ${partition} ${MOUNTPOINT}${directory}
                  check_mountpoint "${partition}" "${MOUNTPOINT}${directory}"
                fi
              fi
              ;;
          esac
          break
        else
          invalid_option
        fi
      done
    fi
    #check if there is no partitions left
    if [[ ${#partitions_list[@]} -eq 0 && ${partition_name[i]} != swap ]]; then
      break
    elif [[ ${partition_name[i]} == another ]]; then
      read_input_text "Configure more partitions"
      [[ $OPTION != y ]] && break
    fi
  done
  pause_function
}

#INSTALL BASE SYSTEM
# Written by Carl Duff.
install_base_system(){
  print_title "INSTALL BASE SYSTEM"
  print_info "Where a wireless device has been detected, packages to support it will be installed automatically."
  print_info "The latest kernel supports newer hardware. The LTS kernel is more stable, and is supported far longer."
  print_info "Whatever the kernel choice, the other can easily be added to an installed system to have both."
  echo
  
  if [[ -n $(dmidecode --type 1 | grep VirtualBox) ]]; then
     print_warning "If installing the LTS Kernel in VirtualBox, the necessary modules must be manually loaded using a terminal AFTER booting the installed system. This need only be done ONCE:"
     echo " $ su"
     echo " # depmod -a"
     echo " # modprobe -a vboxvideo vboxguest vboxsf"
     echo " # reboot" 
  fi
 
  echo
  echo
  echo "${BCyan}Kernel and base-devel selection${Reset}"
  echo "1) Latest Kernel"
  echo "2) Latest Kernel + base-devel"
  echo "3) Long Term Support (LTS) Kernel"
  echo "4) Long Term Support (LTS) Kernel + base-devel"
  echo
  read_input $BASEOPT
  
  case "$OPTION" in
    1) # Latest Kernel
       pacstrap ${MOUNTPOINT} base btrfs-progs ntp sudo
    ;;
    2) # Latest Kernel and base-devel
       pacstrap ${MOUNTPOINT} base base-devel btrfs-progs ntp sudo
    ;;
    3) # LTS Kernel
       pacstrap ${MOUNTPOINT} bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses linux-lts logrotate lvm2 man-db man-pages mdadm nano netctl pacman pciutils pcmciautils perl procps-ng psmisc reiserfsprogs s-nail sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi which xfsprogs btrfs-progs ntp sudo
       LTS=1
    ;;
    4) # LTS Kernel and base-devel
       pacstrap ${MOUNTPOINT} bash bzip2 coreutils cryptsetup device-mapper dhcpcd diffutils e2fsprogs file filesystem findutils gawk gcc-libs gettext glibc grep gzip inetutils iproute2 iputils jfsutils less licenses linux-lts logrotate lvm2 man-db man-pages mdadm nano netctl pacman pciutils pcmciautils perl procps-ng psmisc reiserfsprogs s-nail sed shadow sysfsutils systemd-sysvcompat tar texinfo usbutils util-linux vi which xfsprogs base-devel btrfs-progs ntp sudo
       LTS=1
    ;;
    *) invalid_option
       install_base_system
    ;;
  esac
}
#}}}

#}}}
#CONFIGURE FSTAB {{{
configure_fstab(){
  print_title "CONFIGURE FSTAB"
  print_info "The /etc/fstab file contains static filesystem information. It defines how storage devices and partitions are to be mounted and integrated into the overall system. It is read by the mount command to determine which options to use when mounting a specific partition or partition."
  if [[ ! -f ${MOUNTPOINT}/etc/fstab.aui ]]; then
    cp ${MOUNTPOINT}/etc/fstab ${MOUNTPOINT}/etc/fstab.aui
  else
    cp ${MOUNTPOINT}/etc/fstab.aui ${MOUNTPOINT}/etc/fstab
  fi
  if [[ $UEFI -eq 1 ]]; then
    fstab_list=("DEV" "PARTUUID" "LABEL");
  else
    fstab_list=("DEV" "UUID" "LABEL");
  fi

  PS3="$prompt1"
  echo -e "Configure fstab based on:"
  select OPT in "${fstab_list[@]}"; do
    case "$REPLY" in
      1) genfstab -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab ;;
      2) if [[ $UEFI -eq 1 ]]; then
          genfstab -t PARTUUID -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab
         else
          genfstab -U -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab
         fi
         ;;
      3) genfstab -L -p ${MOUNTPOINT} >> ${MOUNTPOINT}/etc/fstab ;;
      *) invalid_option ;;
    esac
    [[ -n $OPT ]] && break
  done
  echo "Review your fstab"
  [[ -f ${MOUNTPOINT}/swapfile ]] && sed -i "s/\\${MOUNTPOINT}//" ${MOUNTPOINT}/etc/fstab
  pause_function
  gksu leafpad ${MOUNTPOINT}/etc/fstab
}
#}}}
#CONFIGURE HOSTNAME {{{
configure_hostname(){
  print_title "CONFIGURE HOSTNAME"
  print_info "A host name is a unique name created to identify a machine on a network. Host names are restricted to alphanumeric characters.\nThe hyphen (-) can be used, but a host name cannot start or end with it. Length is restricted to 63 characters."
  echo
  read -p "Hostname [ex: archlinux]: " host_name
  echo "$host_name" > ${MOUNTPOINT}/etc/hostname
  if [[ ! -f ${MOUNTPOINT}/etc/hosts.aui ]]; then
    cp ${MOUNTPOINT}/etc/hosts ${MOUNTPOINT}/etc/hosts.aui
  else
    cp ${MOUNTPOINT}/etc/hosts.aui ${MOUNTPOINT}/etc/hosts
  fi
  arch_chroot "sed -i '/127.0.0.1/s/$/ '${host_name}'/' /etc/hosts"
  arch_chroot "sed -i '/::1/s/$/ '${host_name}'/' /etc/hosts"
}
#}}}
#CONFIGURE TIMEZONE {{{
configure_timezone(){
  print_title "CONFIGURE TIMEZONE"
  print_info "In an operating system the time (clock) is determined by four parts: Time value, Time standard, Time Zone, and DST (Daylight Saving Time if applicable)."
  OPTION=n
  while [[ $OPTION != y ]]; do
    settimezone
    read_input_text "Confirm timezone (${ZONE}/${SUBZONE})"
  done
  arch_chroot "ln -s /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime"
}
#}}}
#CONFIGURE HARDWARECLOCK {{{
configure_hardwareclock(){
  print_title "CONFIGURE HARDWARE CLOCK"
  print_info "Unless you are installing alongside windows, pick UTC (Coordinated Universal Time), a global time standard."
  echo
  hwclock_list=('UTC' 'Localtime');
  PS3="$prompt1"
  select OPT in "${hwclock_list[@]}"; do
    case "$REPLY" in
      1) arch_chroot "hwclock --systohc --utc";
        ;;
      2) arch_chroot "hwclock --systohc --localtime";
        ;;
      *) invalid_option ;;
    esac
    [[ -n $OPT ]] && break
  done
}
#}}}

# CONFIGURE KEYMAP - INSTALLED SYSTEM
# Modified by Carl DUff from the select_keymap function to configure the installed system.
configure_keymap(){
  print_title "CONFIGURE KEYMAP"
  print_info "The /etc/vconsole.conf file determines the keyboard layout in the installed system's virtual console. It is not used for desktop environments."
  echo
  pause_function
  OPTION=n
  while [[ $OPTION != y ]]; do
    getkeymap
    read_input_text "Confirm keymap: $KEYMAP"
  done
  echo "KEYMAP=$KEYMAP" > ${MOUNTPOINT}/etc/vconsole.conf
}

#CONFIGURE LOCALE - INSTALLED SYSTEM
configure_locale(){
  print_title "CONFIGURE LOCALE"
  print_info "Locales define the system language used. They are codes starting with two lower-case letters followed by two upper-case letters."
  print_info "The lower-case letters determine the language, and the upper-case letters determine the country. For example 'en_GB' means english, GREAT BRITAIN."
  pause_function
  OPTION=n
  while [[ $OPTION != y ]]; do
    setlocale
    read_input_text "Confirm locale ($LOCALE)"
  done
  echo 'LANG="'$LOCALE_UTF8'"' > ${MOUNTPOINT}/etc/locale.conf
  arch_chroot "sed -i '/'${LOCALE_UTF8}'/s/^#//' /etc/locale.gen"
  arch_chroot "locale-gen"
}

#CONFIGURE MKINITCPIO - INSTALLED SYSTEM
# Amended by Carl Duff. Incorporates LTS kernel option.
configure_mkinitcpio(){
  print_title "CONFIGURE MKINITCPIO"
  print_info "mkinitcpio is a Bash script used to create an initial ramdisk environment to load kernel modules."
  [[ $LUKS -eq 1 ]] && sed -i '/^HOOK/s/block/block keymap encrypt/' ${MOUNTPOINT}/etc/mkinitcpio.conf
  [[ $LVM -eq 1 ]] && sed -i '/^HOOK/s/filesystems/lvm2 filesystems/' ${MOUNTPOINT}/etc/mkinitcpio.conf
  
  # Determine if the LTS kernel installed or not, and run the appropriate mkinitcpio command
  if [[ $LTS -eq 1 ]]; then
     arch_chroot "mkinitcpio -p linux-lts"
  else
     arch_chroot "mkinitcpio -p linux"
  fi
}

#INSTALL BOOTLOADER
install_bootloader(){
  print_title "INSTALL BOOTLOADER"
  print_info "The boot loader is responsible for loading the kernel and initial RAM disk before initiating the boot process."
  print_info "Grub2 is the de-facto choice for Linux users, and is therefore recommended for beginners."
  print_warning "\tROOT Partition: ${ROOT_DISK}"
  print_warning "\tWARNING: There is no support for GRUB + LUKS/LVM."
  if [[ $UEFI -eq 1 ]]; then
    print_warning "\tUEFI Mode Detected"
    bootloaders_list=("Grub2" "Syslinux" "Gummiboot" "Skip")
  else
    print_warning "\tBIOS Mode Detected"
    bootloaders_list=("Grub2" "Syslinux" "Skip")
  fi
  PS3="$prompt1"
  echo -e "Install bootloader:\n"
  select bootloader in "${bootloaders_list[@]}"; do
    case "$REPLY" in
      1)
        pacstrap ${MOUNTPOINT} grub os-prober
        break
        ;;
      2)
        pacstrap ${MOUNTPOINT} syslinux
        break
        ;;
      3)
        [[ $UEFI -eq 1 ]] && pacstrap ${MOUNTPOINT} gummiboot
        break
        ;;
      4)
        [[ $UEFI -eq 1 ]] && break || invalid_option
        ;;
      *)
        invalid_option
        ;;
    esac
  done
  [[ $UEFI -eq 1 ]] && pacstrap ${MOUNTPOINT} efibootmgr dosfstools
}

#CONFIGURE BOOTLOADER - INSTALLED SYSTEM
# Modified by Carl Duff. Removed the "manual" options and the '--debug' flag for non-UEFI grub installations.
configure_bootloader(){
  case $bootloader in
    Grub2)
      print_title "INSTALL GRUB2"
      print_info "The GRand Unified Bootloader (GRUB) is responsible for starting the installed system."
      echo
      if [[ $UEFI -eq 1 ]]; then
         arch_chroot "grub-install --target=x86_64-efi --efi-directory=${EFI_DISK} --bootloader-id=arch_grub --recheck"
      else
         arch_chroot "grub-install --target=i386-pc --recheck ${BOOT_DISK}"
         fi
     
      arch_chroot "grub-mkconfig -o /boot/grub/grub.cfg"
      ;;
      
    Syslinux)
      print_title "INSTALL SYSLINUX"
      print_info "Syslinux is a collection of boot loaders capable of booting from hard drives, CDs, and over the network via PXE. It supports the fat, ext2, ext3, ext4, and btrfs file systems."
      syslinux_install_mode=("[MBR] Automatic" "[PARTITION] Automatic")
      PS3="$prompt1"
      echo -e "Syslinux Install:\n"
      select OPT in "${syslinux_install_mode[@]}"; do
        case "$REPLY" in
          1)
            arch_chroot "syslinux-install_update -iam"
            if [[ $LUKS -eq 1 ]]; then
              sed -i "s/APPEND root=.*/APPEND root=\/dev\/mapper\/${ROOT_PART} cryptdevice=\/dev\/${LUKS_DISK}:crypt ro/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            elif [[ $LVM -eq 1 ]]; then
              sed -i "s/sda[0-9]/\/dev\/mapper\/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            else
              sed -i "s/sda[0-9]/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            fi
            print_warning "The partition in question needs to be whatever you have as / (root), not /boot."
            pause_function
            gksu leafpad ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            break
            ;;
          2)
            arch_chroot "syslinux-install_update -i"
            if [[ $LUKS -eq 1 ]]; then
              sed -i "s/APPEND root=.*/APPEND root=\/dev\/mapper\/${ROOT_PART} cryptdevice=\/dev\/${LUKS_DISK}:crypt ro/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            elif [[ $LVM -eq 1 ]]; then
              sed -i "s/sda[0-9]/\/dev\/mapper\/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            else
              sed -i "s/sda[0-9]/${ROOT_PART}/g" ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            fi
            print_warning "The partition in question needs to be whatever you have as / (root), not /boot."
            pause_function
            gksu leafpad ${MOUNTPOINT}/boot/syslinux/syslinux.cfg
            break
            ;;
          *) 
             invalid_option
            ;;
        esac
      done
      ;;
    Gummiboot)
      print_title "INSTALL GUMMIBOOT"
      print_info "Gummiboot is a UEFI boot manager written by Kay Sievers and Harald Hoyer. It is simple to configure, but can only start EFI executables, the Linux kernel EFISTUB, UEFI Shell, grub.efi, and such."
      print_warning "\tGummiboot heavily suggests that /boot is mounted to the EFI partition, not /boot/efi, in order to simplify updating and configuration."
 
      arch_chroot "gummiboot install"
      print_warning "Please check your .conf file"
      partuuid=`blkid -s PARTUUID ${ROOT_DISK} | awk '{print $2}' | sed 's/"//g' | sed 's/^.*=//'`
      
      if [[ $LUKS -eq 1 ]]; then
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\tcryptdevice=\/dev\/${LUKS_DISK}:luks root=\/dev\/mapper\/${ROOT_PART} rw" > ${MOUNTPOINT}/boot/loader/entries/arch.conf
      elif [[ $LVM -eq 1 ]]; then
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=\/dev\/mapper\/${ROOT_PART} rw" > ${MOUNTPOINT}/boot/loader/entries/arch.conf
      else
            echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=PARTUUID=${partuuid} rw" > ${MOUNTPOINT}/boot/loader/entries/arch.conf
      fi

      echo -e "default  arch\ntimeout  5" > ${MOUNTPOINT}/boot/loader/loader.conf
      pause_function
      gksu leafpad ${MOUNTPOINT}/boot/loader/entries/arch.conf
      gksu leafpad ${MOUNTPOINT}/boot/loader/loader.conf
      ;;
  esac      
}

#ROOT PASSWORD {{{
root_password(){
  print_title "ROOT PASSWORD"
  print_info "Root is essentially the admin or super-user account."
  print_info "You may use the same password for both the root and personal user accounts."
  echo
  print_warning "Enter your new root password"
  arch_chroot "passwd"
  pause_function
}

#CREATE NEW USER
# Modified /simplified  by Carl Duff from the AUI script. Option to pick default editor
# has been removed, and arch_chroot functions added as this is not being run from the
# installed system.
  create_new_user(){
	print_title "CREATE NEW USER"
	print_info "Enter your personal account username. You will then be asked for a password. This can be the same as that used for Root."
    print_info "This option may be repeated to add any number of users."
    echo 
    read -p "Username: " username
    arch_chroot "useradd -m -g users -G wheel,storage,power -s /bin/bash ${username}"
    arch_chroot "passwd ${username}"
    pause_function
    if $(grep ${username} /etc/shadow | grep ! &> /dev/null ); then
      create_new_user
    else
      arch_chroot "cp /etc/skel/.bashrc /home/${username}"
      arch_chroot "chown -R ${username}:users /home/${username}"
      arch_chroot "sed -i '/%wheel ALL=(ALL) ALL/s/^#//' /etc/sudoers"
    fi
  }


#INSTALL SYNAPTICS, XORG AND ALSA PACKAGES
# Written by Carl Duff.
install_alsa_xorg_input() {
 print_title "INSTALL GRAPHICS, INPUT, AND SOUND PACKAGES/DRIVERS"
 print_info "Before installing graphics card driver(s) or desktop environments, other packages are needed first:"
 echo
 print_info "alsa         - Advanced Linux Sound Architecture. Device drivers for sound cards."
 print_info "xorg-*       - Packages providing an open-source implementation of the X window system, needed for graphical interfaces."
 print_info "xf86-input-* - Packages providing open-source drivers for keyboards, touchpads, etc."
 echo
 print_warning "Once this process has been completed, graphics card driver(s) will be installed."
 echo
 pause_function
 pacstrap ${MOUNTPOINT} alsa-utils xorg-server xorg-server-utils xorg-xinit xf86-input-synaptics xf86-input-keyboard
 
 # Use the keymap input in the first option to create the X11 keyboard configuration file for the installed system
   echo -e "Section "\"InputClass"\"\nIdentifier "\"system-keyboard"\"\nMatchIsKeyboard "\"on"\"\nOption "\"XkbLayout"\" "\"${KEYMAP_XKB:0:2}"\"\nEndSection" > ${MOUNTPOINT}/etc/X11/xorg.conf.d/00-keyboard.conf

 pause_function
}

#INSTALL GRAPHCS CARD DRIVER
# Written by Carl Duff. This replaces the install_video_card and detect_vga functions.
# The intention is to remove too much automation from the installation process.

install_graphics_card_driver(){
  
  # VirtualBox installation
  if [[ -n $(dmidecode --type 1 | grep VirtualBox) ]]; then
    print_title "VIRTUALBOX INSTALLATION DETECTED"
    
  # LTS Kernel installed 
    if [[ $LTS -eq 1 ]]; then
       print_warning "As the LTS Kernel has been installed, the configuration process can only be semi-automated:"
       print_info "- virtualbox-guest-utils, virtualbox-guest-modules-lts, and mesa-libgl packages will be installed."
       print_info "- vboxservice for systemd will be enabled (systemctl enable vboxservice)"
       print_warning "After booting into the installed system, enter the following commands into the terminal to manually load the modules. This need only be done ONCE:"
       echo " $ su"
       echo " # depmod -a"
       echo " # modprobe -a vboxvideo vboxguest vboxsf"
       echo " # reboot" 
       echo
       pause_function
       pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-modules-lts mesa-libgl
    
    else  
    # Standard Kernel installed
       print_warning "As Arch is being installed in Virtualbox, the configuration process will be automated:"
       print_info "- virtualbox-guest-utils. virtualbox-guest-modules, and mesa-libgl packages will be installed"
       print_info "- vboxguest, vboxsf, and vboxvideo kernel modules will be loaded via the modprobe command"
       print_info "- vboxservice for systemd will be enabled (systemctl enable vboxservice)"
       echo
       pause_function
       pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-modules mesa-libgl   
       arch_chroot "modprobe -a vboxguest vboxsf vboxvideo"   
    fi
  
    # Enable vboxservice whatever the kernel type
    arch_chroot "systemctl enable vboxservice"

   # Real Hardware Installation
   else 
     print_title "GRAPHICS CARD CONFIGURATION"
     print_warning "Only open source drivers are currently provided."
     print_info "- AMD's Catalyst driver is not officially supported by Arch Linux. Use Radeon instead."
     print_info "- Nouveau is the open source driver for NVIDIA graphics cards."
     print_info "- If your graphics card is not listed here - or if you are not sure - pick VESA."
     echo
     echo "1) Bumblebee"
     echo "2) Intel"
     echo "3) NVIDIA / Nouveau"
     echo "4) AMD / Radeon"
     echo "5) VESA (generic)"
     echo
     read_input $GRAPHICS_CARD
     case "$OPTION" in
     1) # Bumblebee
        pacstrap ${MOUNTPOINT} bumblebee xf86-video-nouveau nouveau-dri primus virtualgl mesa-libgl mesa xf86-video-vesa
        arch_chroot "gpasswd -a ${username} bumblebee"
        arch_chroot "systemctl enable bumblebeed" 
        ;;      
     2) # Intel 
        pacstrap ${MOUNTPOINT} xf86-video-intel intel-dri libva-intel-driver mesa-libgl mesa xf86-video-vesa
        ;;
     3) # NVIDIA / Nouveau
        pacstrap ${MOUNTPOINT} xf86-video-nouveau nouveau-dri mesa-libgl mesa xf86-video-vesa
        ;;
     4) # AMD / Radeon
        pacstrap ${MOUNTPOINT} xf86-video-ati ati-dri mesa-libgl mesa xf86-video-vesa
        ;;
     5) # VESA 
        pacstrap ${MOUNTPOINT} xf86-video-vesa mesa-libgl mesa
        ;;
     *) invalid_option
        install_graphics_card_driver
        ;;
     esac
  fi
  pause_function
}  

#INSTALL DESKTOP ENVIRONMENT AND WINDOW MANAGER
# Written by Carl Duff. adapted from and replaces the original install_desktop_environment function, along with its
# multiple sub-functions. Again, this was for the purpose of simplification.
install_de_wm(){
  print_title "INSTALL DESKTOP ENVIRONMENT OR WINDOW MANAGER"
  print_warning "This option may be repeated to install multiple environments."
  print_info "Gnome, Cinnamon, and KDE come with a network manager, which will automatically be enabled where downloaded."
  print_info "There may be a one-time option presented to install some necessary extra packages after installation."
  echo
  echo "${BCyan}Full Desktop Environments${Reset}"
  echo " 1) Cinnamon                   5) LXDE"
  echo " 2) Enlightenment              6) MATE (2 options)"
  echo " 3) Gnome 3  (3 options)       7) XFCE (2 options)"
  echo " 4) KDE      (2 options)"
  echo
  echo "${BCyan}Window Managers${Reset}"
  echo " 8) Awesome                   11) IceWM"
  echo " 9) FluxBox                   12) Openbox"
  echo "10) i3                        13) PekWM"     
  echo ""
  echo " b) Back"
  echo
  read_input $DESKTOPENV
  
  case "$OPTION" in
    1) #Cinnamon
       pacstrap ${MOUNTPOINT} cinnamon
       
       if [[ $NM_INSTALLED -eq 0 ]]; then       
          arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service && systemctl enable ModemManager.service"
          NM_INSTALLED=1
       fi
    ;;
    2) #Enlightenment
       pacstrap ${MOUNTPOINT} enlightenment terminology lxpolkit
    ;;
    3) #Gnome (3 choices)
        print_title "GNOME"
        print_info "There are three installation options available for Gnome. The Minimal option DOES NOT include a network manager."
        echo " 1) Minimal              (gnome-shell)"
        echo " 2) Full                 (gnome)"
        echo " 3) Full + Extras        (gnome + gnome-extra)"
        echo 
        echo " b) Back"
        echo ""
        read_input $DE_CH
        case "$OPTION" in
        1) pacstrap ${MOUNTPOINT} gnome-shell gdm
           GNOME_INSTALLED=1
          ;;
        2) pacstrap ${MOUNTPOINT} gnome

           if [[ $NM_INSTALLED -eq 0 ]]; then       
              arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service && systemctl enable ModemManager.service"
              NM_INSTALLED=1
           fi
           
           GNOME_INSTALLED=1
          ;;
        3) pacstrap ${MOUNTPOINT} gnome gnome-extra

           if [[ $NM_INSTALLED -eq 0 ]]; then       
              arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service && systemctl enable ModemManager.service"
              NM_INSTALLED=1
           fi
           
           GNOME_INSTALLED=1
          ;;
        *) invalid_option
           install_de_wm
          ;;
        esac
    ;;    
    4) #KDE (2 choices)
        print_title "KDE"
        print_info "There are two installation options available. The Minimal option DOES NOT include a network manager."
        echo " 1) Minimal       (kdebase)"
        echo " 2) Full          (kde)"
        echo 
        echo " b) Back"
        echo ""
        read_input $DE_CH
        case "$OPTION" in
        1) # KDE BASE
           pacstrap ${MOUNTPOINT} kdebase-workspace kdeplasma-applets-plasma-nm
           KDE_INSTALLED=1
          ;;
        2) # KDE FULL
           pacstrap ${MOUNTPOINT} kde kdeplasma-applets-plasma-nm xdg-user-dirs xdg-utils

           if [[ $NM_INSTALLED -eq 0 ]]; then       
              arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service && systemctl enable ModemManager.service"
              NM_INSTALLED=1
           fi
               
           KDE_INSTALLED=1
          ;;
        *) invalid_option
           install_de_wm
          ;;
        esac
    ;;    
    5) #LXDE 
       pacstrap ${MOUNTPOINT} lxde
       LXDE_INSTALLED=1
    ;;
    6) #MATE
       print_title "MATE"
       print_info "There are two installation options available."
       echo " 1) Full          (mate)"
       echo " 2) Full + Extras (mate + mate-extra)"
       echo 
       echo " b) Back"
       echo ""
       read_input $DE_CH
       case "$OPTION" in
       1) pacstrap ${MOUNTPOINT} mate
          ;;
       2) pacstrap ${MOUNTPOINT} mate mate-extra
          ;;
        *) install_de_wm
          ;;
        esac   
    ;;
    7) # XFCE
       print_title "XFCE"
       print_info "There are two installation options available."
       echo " 1) Full          (xfce4)"
       echo " 2) Full + Extras (xfce4 + xfce4-goodies)"
       echo
       echo " b) Back"
       echo ""
       read_input $DE_CH
       case "$OPTION" in
       1) pacstrap ${MOUNTPOINT} xfce4 lxpolkit
          ;;
       2) pacstrap ${MOUNTPOINT} xfce4 xfce4-goodies lxpolkit
          ;;
        *) install_de_wm
          ;;
        esac    
    ;;
    8) #Awesome
       pacstrap ${MOUNTPOINT} awesome vicious lxpolkit 
    ;;
    9) #Fluxbox 
       pacstrap ${MOUNTPOINT} fluxbox fbnews fluxter lxpolkit
    ;;
    10) #i3
        pacstrap ${MOUNTPOINT} i3-wm i3lock i3status lxpolkit
    ;;
    11) #IceWM
        pacstrap ${MOUNTPOINT} icewm icewm-themes lxpolkit
    ;;
    12) #Openbox
        pacstrap ${MOUNTPOINT} openbox openbox-themes lxpolkit
    ;;
    13) #PekWM
        pacstrap ${MOUNTPOINT} pekwm pekwm-themes lxpolkit   
    ;;
    "b") break
    ;;
    *) invalid_option
       install_de_wm
 esac
 pause_function          
}

#INSTALL COMMON PACKAGES
# Written by Carl Duff. Installs basic/common packages required for functionalty.
install_common(){
 print_title "COMMON PACKAGES"
 print_info "Some environments require common files to be installed, particularly for permissions, creation of home folders, and file manager functionality."
 print_info "Packages include: xterm, xdg-user-dirs, gksu, gnome-keyring, polkit, gvfs, and the gnome-icon-theme, etc."
 print_info "Those installing the full KDE desktop alone will not need to install these."
 print_warning "This is the only time you have the option!"
 echo " 1) Yes, install these packages"
 echo " 2) No, ${Bold}DO NOT${Reset} install these packages"
 echo
 read_input $DE_CH
 
 if [[ $OPTION -eq 1 ]]; then
    pacstrap ${MOUNTPOINT} xterm gksu gnome-keyring polkit xdg-user-dirs xdg-utils gamin gvfs gvfs-afc gvfs-smb ttf-dejavu gnome-icon-theme python2-xdg
 fi 
 
 COMMON_INSTALLED=1
}

#INSTALL DISPLAY MANAGER
# Written by Carl Duff. Detects if KDE and/or GNOME has been installed to ask which DM is desired. Otherwise
# present choice between LXDM and LightDM. No SLiM as this seems to have issues.
install_dm() {
   if    [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 0 ]]; then
         print_title "DISPLAY MANAGER: KDE INSTALLED"
         print_info "As KDE has been installed, its native display manager - KDM - has now been enabled."
         arch_chroot "systemctl enable kdm.service"
         pause_function
                  
  elif   [[ $KDE_INSTALLED -eq 0 ]] && [[ $GNOME_INSTALLED -eq 1 ]]; then
         print_title "DISPLAY MANAGER: GNOME INSTALLED"
         print_info "As Gnome has been installed, its native display manager - GDM - has now been enabled."
         arch_chroot "systemctl enable gdm.service"
         pause_function
  
  elif   [[ $KDE_INSTALLED -eq 1 ]] && [[ $GNOME_INSTALLED -eq 1 ]]; then
         print_title "DISPLAY MANAGER: KDE AND GNOME INSTALLED"
         print_info "Both the KDE and Gnome Display Managers have been installed. Please choose one to enable."
         echo " 1) GDM (Gnome)"
         echo " 2) KDM (KDE)"
         echo ""
         read_input $DM_CH
         case "$OPTION" in
           1) arch_chroot "systemctl enable gdm.service"
           ;;
           *) arch_chroot "systemctl enable kdm.service"
           ;;
         esac
         pause_function
         
  elif   [[ $LXDE_INSTALLED -eq 1 ]]; then
         print_title "DISPLAY MANAGER: LXDE INSTALLED"
         print_info "As LXDE has been installed, its native display manager - LXDM - has now been enabled."
         arch_chroot "systemctl enable lxdm.service"
         pause_function
         
  elif   [[ $DM_INSTALLED -eq 0 ]]; then
         print_title "INSTALL DISPLAY MANAGER: CHOOSE LXDM OR LIGHTDM"
         print_warning "Some desktop environments come with a display manager by default, which will be detected in this section. Ensure all desired desktop environments have been installed first."
         print_info "Please choose between LXDM or LightDM. LXDM is recommended for beginners."
         echo " 1) LXDM"
         echo " 2) LightDM"
         echo
         echo " b) Back"
         echo
         read_input $DM_CH
         case "$OPTION" in
           1) # LXDM
              pacstrap ${MOUNTPOINT} lxdm
              arch_chroot "systemctl enable lxdm.service"
              ;;
           2) # LIGHTDM
              pacstrap ${MOUNTPOINT} lightdm lightdm-gtk3-greeter
              arch_chroot "systemctl enable lightdm.service"
              ;;
          "b") break
              ;;
           *) invalid_option
              install_dm
              ;;
         esac
         DM_INSTALLED=1
         pause_function
 
 else    print_title "INSTALL DISPLAY MANAGER: OPTION ALREADY COMPLETED"
         print_info "LXDM or LightDM has already been installed and enabled."
         echo
         pause_function
 fi       
 }        
         
#SET UP NETWORK FOR INSTALLED SYSTEM
setup_network_manager(){
 print_title "NETWORK MANAGEMENT"
 
 if [[ $NM_INSTALLED -eq 0 ]]; then
 
    print_warning "Some desktop environments come with a network manager by default, which will be automatically enabled. Ensure all desired desktop environments have been installed first."
    print_info "Network connection managers can automatically manage wireless and wired interfaces."
    print_info "Network Manager is recommended for beginners, especially where using a wireless connection."
    echo
    echo "${BCyan}Network Manager selection${Reset}"
    echo "1) Connman (command line)"
    echo "2) dhcpcd  (command line)"
    echo "3) Network Manager (desktop graphical interface)"
    echo "4) WICD (desktop graphical interface)"
    echo
    echo "b) Back"
    echo
    read_input $NETMANOPT
  
    case "$OPTION" in
      1) # connman
         pacstrap ${MOUNTPOINT} connman
         arch_chroot "systemctl enable connman.service"
         ;;
      2) # dhcpcd
         arch_chroot "systemctl enable dhcpcd.service"
         ;;
      3) # Network Manager
         pacstrap ${MOUNTPOINT} networkmanager network-manager-applet
         arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service && systemctl enable ModemManager.service"
         ;;
      4) # WICD
         pacstrap ${MOUNTPOINT} wicd-gtk
         arch_chroot "systemctl enable wicd.service"
         ;;
     "b") break
         ;;
      *) invalid_option
         setup_network_manager  
        ;;
     esac
  
 else
  
    print_info "A network manager has already been installed and enabled."
    echo
    pause_function
  
 fi
}

    
#}}}
#FINISH {{{
# Modified and simplified by Carl Duff. Removed code to copy AUI script to the installed system, 
# and now automatically unmount partitions. and ask user to reboot their system manually.
finish(){
  print_title "INSTALLATION COMPLETED!"
  umount_partitions
  print_info "You can reboot or power off your system."

  if [[ $LTS -eq 1 ]] && [[ -n $(dmidecode --type 1 | grep VirtualBox) ]]; then
     print_warning "After booting into the installed system, enter the following commands into the terminal to manually load the Virtualbox modules for the LTS kernel. This need only be done ONCE:"
     echo " $ su"
     echo " # depmod -a"
     echo " # modprobe -a vboxvideo vboxguest vboxsf"
     echo " # reboot" 
     echo
  fi

  pause_function
  exit 0
}
#}}}

# Modified by Carl Duff. Removed original check_connection option as new one implemented.
print_title "Evo/Lution-AIS Arch Installer v0.2"
check_boot_system
echo
print_info "Checking installer has been run as root, and that there is an active internet connection. Please wait..."
check_evo_requirements
print_info "${Green}All checks passed"
pacman -Sy
echo
print_warning "Please maximise this window for best results"
echo
echo "Lution-AIS is based on the AIS and AUI scripts written by Helmuth Saatkamp."
echo
pause_function
mainmenu() {
while true
do
  print_title "Evo/Lution-AIS Arch Installer v0.2: MAIN MENU"
  print_warning "Each step can be repeated, but must be followed IN ORDER."
 echo "${BCyan}Base Installation${Reset}"
  echo " 1) $(mainmenu_item "${checklist[1]}" "Configure Desktop Keyboard layout")"
  echo " 2) $(mainmenu_item "${checklist[2]}" "Configure Mirrorlist (optional)")"
  echo " 3) $(mainmenu_item "${checklist[3]}" "Partition Disk")"
  echo " 4) $(mainmenu_item "${checklist[4]}" "Install Base System")"
  echo " 5) $(mainmenu_item "${checklist[5]}" "Configure Fstab")"
  echo " 6) $(mainmenu_item "${checklist[6]}" "Configure Hostname")"
  echo " 7) $(mainmenu_item "${checklist[7]}" "Configure Timezone and Hardware Clock")"
  echo " 8) $(mainmenu_item "${checklist[8]}" "Configure Virtual Console Keyboard Layout and System Locale")"
  echo " 9) $(mainmenu_item "${checklist[9]}" "Run Mkinitcpio")"
  echo "10) $(mainmenu_item "${checklist[10]}" "Install Bootloader")"
  echo "11) $(mainmenu_item "${checklist[11]}" "Configure Root Password")"
  echo "12) $(mainmenu_item "${checklist[12]}" "Configure User Account(s)")"
  echo
  echo "${BCyan}Desktop Installation${Reset}"
  echo "13) $(mainmenu_item "${checklist[13]}" "Install ALSA, Xorg, Xf86-input, and Graphics Card Driver(s)")"
  echo "14) $(mainmenu_item "${checklist[14]}" "Install Desktop Environment(s)")"
  echo "15) $(mainmenu_item "${checklist[14]}" "Install Network Manager")"  
  echo "16) $(mainmenu_item "${checklist[15]}" "Install Display Manager (semi-automated)")"  
  echo ""
  echo " d) Done"
  echo ""
  read_input_options
  for OPT in ${OPTIONS[@]}; do
    case "$OPT" in
      1)
        select_keymap_xkb
        checklist[1]=1
        ;;
      2)
        configure_mirrorlist
        checklist[2]=1
        ;;
      3)
        umount_partitions
        create_partition_scheme
        format_partitions
        checklist[3]=1
        ;;
      4)
        install_base_system
        checklist[4]=1
        ;;
      5)
        configure_fstab
        checklist[5]=1
        ;;
      6)
        configure_hostname
        checklist[6]=1
        ;;
      7)
        configure_timezone
        configure_hardwareclock
        checklist[7]=1
        ;;
      8)
        configure_keymap
        configure_locale
        checklist[8]=1
        ;;
      9)
        configure_mkinitcpio
        checklist[9]=1
        ;;
      10)
        install_bootloader
        configure_bootloader
        checklist[10]=1
        ;;
      11)
        root_password
        checklist[11]=1
        ;;
      12)
        create_new_user
        checklist[12]=1
        ;; 
       13)
        install_alsa_xorg_input
        install_graphics_card_driver
        checklist[13]=1
        ;;     
       14)
         install_de_wm         

         if [[ $COMMON_INSTALLED -eq 0 ]]; then
            install_common
         fi
         
         checklist[14]=1
        ;;
       15) 
          setup_network_manager
          checklist[15]=1
        ;;        
       16)
         install_dm
         checklist[16]=1
        ;;
      "d")
        finish
        ;;
      *)
        mainmenu
        ;;
    esac
  done
done
}
mainmenu
#}}}
